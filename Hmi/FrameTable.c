//----------------------------------------------------------------------------------------------------------
/*
 <pre>
 Copyright              Copyright ABB, 2004.
                        All rights reserved. Reproduction, modification,
                        use or disclosure to third parties without express
                        authority is forbidden.

 System                                 Generic
 Subsystem                              HMI
 Description                    Frame Table of the HMI subsystem, contains definitions for all frames displayed on the local HMI.
                                                Contains and manages string tables for all fixed strings that may be displayed in all supported languages

 Remarks
 $Id $
 </pre>
*/
//----------------------------------------------------------------------------------------------------------

#pragma diag_suppress=Go003

/****** FrameTable.c ******/
#include <intrinsics.h>

#include "IncludeList_Implementation.h"

#include "System/Interface/system.h"

#ifdef LOCALSERVER_SELECT
	#include "UnitTests/LocalServer/webserver_main.h"
#endif

#if(HOST_FRAMEWORK_VERSION < 0x020300)
#include "../../common/interface/common_type.h"
#include "../../common/interface/assert.h"
#else
#include "System/Interface/common_type.h"
#include "System/Interface/assert.h"
#endif
#include "RTOS/Interface/rtos.h"
// get the SUBSYSTEM IDs
#include "T_DATA_OBJ/Interface/simple_type.h"
#include "T_DATA_OBJ/Interface/t_data_obj.h"
#include "T_Unit/Interface/t_unit.h"
#include "Coordinator/Interface/subsystem_idx.h"


#include "Common/Interface/common_units.h"

#ifdef LOCALSERVER_SELECT
    #include "Hmi/HmiGen/VT5/source/specialOperation.h"
    #include "Hmi/HmiGen/VT5/source/specialOperationFunctions.h"
#endif

#include "T_DATA_OBJ/Interface/t_data_obj_uom_pf.h"	// added! cause of new units of meassure
#include "T_DATA_OBJ/Interface/t_data_obj_units.h"
#include "T_DATA_OBJ/Interface/t_data_obj_floatunits.h"
#include "T_DATA_OBJ/Interface/t_data_obj_float_fixedunit.h"
#include "T_DATA_OBJ/Interface/t_data_obj_rngflt.h"
#include "T_DATA_OBJ/Interface/t_data_obj_dev_rngflt.h"
#include "T_DATA_OBJ/Interface/t_data_obj_floatfloatunits.h"
#include "T_DATA_OBJ/Interface/t_data_obj_floatrange_fixedunit.h"
#include "T_DATA_OBJ/Interface/t_data_obj_tabenum8.h"
#include "Totalizer/Interface/Totalizer.h"
//#include "..\..\Totalizer\interface\t_data_obj_totdispunits.h"
#include "T_DATA_OBJ/Interface/t_data_obj_float_uomunit.h"
#include "Totalizer/Interface/t_data_obj_totdisp.h"

//ServicePort
#include "ServicePort/Interface/servicePort.h"

#include "Hmi/Interface/HMI_idx.h"
#include "Hmi/Interface/HMI.h"

#include "frameTableDefinitions.h"

#if defined(HMI_SUPPORTS_GRAPH_VIEW) || defined(HMI_SUPPORTS_GRAPH_PARAM_FRAMES)
#include "TrendView.h"
#endif

#include "hmi_types.h"
#include "hmi_attributes.h"
#include "FixedIconDefinitions.h"

#include "IncludeList_Frames_1.h"
#include "IncludeList_Frames_2.h"

#include "stringTable_s.h"
#include "FrameTable.h"

#include "keystateDefinitions.h"
#include "adjuster.h"

#include "FrameMover.h"

#ifdef AZ200_SPECIAL_FEATURES_HMI
#include "../../O2_Calibration/Interface/o2_Calibration.h"
#endif

#ifdef EDP300_SPECIAL_FEATURES_HMI
#include "EDP300_Mode.h"
#endif

#ifdef HMI_SUPPORTS_ASIAN
    #if !defined(HMIGEN_RELEASE_VERSION) || !defined(HMIGEN_MAJOR_VERSION) || !defined(HMIGEN_MINOR_VERSION) || !defined(HMIGEN_CONFIG_VERSION) || ((HMIGEN_RELEASE_VERSION == 0) && (HMIGEN_MAJOR_VERSION < 11)) || ((HMIGEN_RELEASE_VERSION > 0) && (HMIGEN_MAJOR_VERSION < 11))
        #error Files generated by an old version of HMIGen are not compatible. Use HMIGen Version "1.11.x.x" or newer
    #endif
#else
    #if !defined(HMIGEN_RELEASE_VERSION) || !defined(HMIGEN_MAJOR_VERSION) || !defined(HMIGEN_MINOR_VERSION) || !defined(HMIGEN_CONFIG_VERSION) || ((HMIGEN_RELEASE_VERSION == 0) && (HMIGEN_MAJOR_VERSION < 10)) || ((HMIGEN_RELEASE_VERSION > 0) && (HMIGEN_MAJOR_VERSION < 5))
        #error Files generated by an old version of HMIGen are not compatible. Use HMIGen Version "1.5.x.x" or newer
    #endif
#endif


#ifdef HMI_SUPPORTS_WAVEFORM_FRAMES
#include "wavefornFrameDefinitions.h"
#include "../../waveform/interface/waveform.h"
#endif

#ifdef HMI_SUPPORTS_MATRIX_FRAMES
#include "../../matrix/interface/matrix.h"
#endif

#if defined(HMI_SUPPORTS_MATRIX_FRAMES) || defined(HMI_SUPPORTS_LINEARIZER_FRAMES)
#include "writeProtect.h"
#endif


// private variables

TUSIGN8 ParameterDumpFont = 0;

#ifdef HMI_SUPPORTS_SERVICEPORT
typedef struct
{
    // elements that must be initialised
    FRAME_FORMAT_TYPE const *currentFrame;
    TUSIGN8                 editEnabled;
    TUSIGN8                 cursorPosition;
    TUSIGN8                 cursorPositionLimit;
    TBOOL                   autoscroll;
    TBOOL                   nvTestFrameActive;
    FRAME_FORMAT_TYPE const *startupFrame;
    TBOOL                   SpecialOpDenyEdit;

    #ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
    TBOOL                   OutputHold_enable;
    #endif

    #ifdef HMI_SUPPORTS_AUTO_ADJUST
    TBOOL                   AutoAdjustAbort_enable;
    #endif

    #ifdef HMI_SUPPORTS_SECONDARY_IDENTIFIER
    TBOOL                   SecondaryIdentifier_Enable;
    #endif

    #ifdef HMI_SUPPORTS_MANUAL_ADJUST_MODIFIER
    TUSIGN8                 ManualAdjustModifier;
    #endif

    #ifdef HMI_SUPPORTS_SEQUENCES
    TBOOL                   SequentialMenuEnable;
    #endif

    #ifdef HMI_SUPPORTS_MANUAL_VALVE_CAL
    TBOOL                   ManualValveCalEnable;
    #endif

    #ifdef HMI_SUPPORTS_CONFIG_CHANGE_COUNTER
    TBOOL                   ConfigChangeCounter_enable;
    #endif

    #ifdef HMI_SUPPORTS_AUTO_CALIBRATION
    TBOOL                   NavigationFromAutoCalAllowed;
    TBOOL                   AutoCalRenamed;
    TBOOL                   AutoCalSettlingRemoved;
    #endif

    #ifdef HMI_SUPPORTS_MANUAL_CALIBRATION
    TBOOL                   SampleCollectionEnabled;
    #endif

    #ifdef DISPLAY_DIAGNOSIS_CONDITION_DETAILS
    TBOOL                   DiagDetailsViewActive;
    TUSIGN8                 DiagDetailsCursor;
    #endif

    // elements that need not be initialised
    TUSIGN8                 RequestedARMLevel;
    TBOOL                   operatorFrameActive;

    #ifdef HMI_SUPPORTS_EASYSETUP
    TUSIGN8                 easySetup_lastStage;
    TUSIGN8                 easySetup_actualStage;
    #endif

    TUSIGN8                 menuPosnCursor;
    TUSIGN8                 menuPosnCursorLim;

    #if defined (TYPE_4_IMPLEMENTATION) || defined (TYPE_5_IMPLEMENTATION)
    TUSIGN8                 nValidItems;
    TUSIGN8                 selectedValidItem;
    #endif

    #ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
    TUSIGN8  OutputHoldState_ssIdx;
    TUSIGN8  OutputHoldState_objIdx;
    TUSIGN8  OutputHoldState_attIdx;
    #endif

    #ifdef HMI_SUPPORTS_AUTO_ADJUST
    TUSIGN8  AutoAdjustAbort_ssIdx;
    TUSIGN8  AutoAdjustAbort_objIdx;
    TUSIGN8  AutoAdjustAbort_attIdx;
    #endif

    #ifdef HMI_SUPPORTS_SECONDARY_IDENTIFIER
    TUSIGN8     SecondaryIdentifier_Text[SECONDARY_IDENTIFIER_LEN];
    #endif

    #ifdef HMI_SUPPORTS_TIME_DATE_PARAM_FRAMES
    TUSIGN32    TimeDurationLimit;
    #endif

    #ifdef HMI_SUPPORTS_SEQUENCES
    TUSIGN8     SequentialMenuPosnCursor;
    TUSIGN8     SequentialMenuPosnCursorLim;
    TUSIGN16    SequentialMenuTableOffset;
    #endif

    #ifdef ENUM_ACCELERATOR
    TUSIGN8 EnumAccellerator;
    #endif

    #ifdef STRING_ACCELERATOR
    TUSIGN8 StringAccellerator;
    #endif

    #ifdef IPADDR_ACCELERATOR
    TUSIGN8 IPAddrAccellerator;
    #endif

    #ifdef DATE_TIME_ACCELERATOR
    TUSIGN8 DateTimeAccellerator;
    #endif

    #ifdef MANUAL_ADJUST_ACCELERATOR
    TUSIGN8 ManAdjAccellerator;
    TUSIGN8 ManAdjMaxAccelleratorStage;
    TUSIGN8 ManAdjBargraphValueCharacters;
    TUSIGN8 ManAdjBargraphValuePrecision;
    #endif

    #ifndef DISABLE_BACK_MOVE_SELECT
    FRAME_FORMAT_TYPE const *mostRecentStandardMenu;
    #endif

    #ifdef HMI_SUPPORTS_CONFIG_CHANGE_COUNTER
    TUSIGN16                ConfigChangeCounter_ssIdx;
    TUSIGN16                ConfigChangeCounter_obIdx;
    TINT16                  ConfigChangeCounter_atIdx;
    #endif

    #ifdef HMI_USES_INDIRECT_TEXT
    TUSIGN8                 derivedString[21];
    #endif

    #if defined(HMI_SUPPORTS_WAVEFORM_FRAMES) || defined(HMI_SUPPORTS_MATRIX_FRAMES) || defined(HMI_SUPPORTS_LINEARIZER_FRAMES)
    FRAME_FORMAT_TYPE       inherentNumericFrame;
    #endif

    #ifdef HMI_SUPPORTS_MATRIX_FRAMES
    TUSIGN8                 matrixColumn;
    TUSIGN8                 matrixRow;
    MATRIX_CURSOR_POS       matrixCursor;
    #endif

    #ifdef HMI_SUPPORTS_LINEARIZER_FRAMES
    LINEARIZER_CURSOR_POS   linearizerCursor;
    TUSIGN8                 linearizerPoint;
    TBOOL                   linearizerProcessValueDisplay_Enabled;
    TBOOL                   linearizerInpointCapture_Enabled;
    TBOOL                   linearizerInpointEdit_Enabled;
    TBOOL                   linearizerOutpointEdit_Enabled;
    TBOOL                   linearizerPointEnableDisable_Enabled;
    TUSIGN8                 linearizerPoint_max;
#endif


    TBOOL                   NumericCharacterSetAllowSpace;
    TUSIGN8                 NumericCharacterSetMinValid;
    TUSIGN8                 NumericCharacterSetMaxValid;

}FRAME_TABLE_LOCAL_TYPE;

#pragma diag_suppress=Pm022
#pragma diag_suppress=Pm023
FRAME_TABLE_LOCAL_TYPE  FrameTableLocal_1 = {
     NULL           // FRAME_FORMAT_TYPE const *currentFrame
    ,0              // TUSIGN8                 editEnabled
    ,0              // TUSIGN8                 cursorPosition
    ,0              // TUSIGN8                 cursorPositionLimit
    ,eTRUE          // TBOOL                   autoscroll
    ,eFALSE         // TBOOL                   nvTestFrameActive
    ,STARTINGFRAME  // FRAME_FORMAT_TYPE const *startupFrame
    ,eFALSE         // TBOOL                   SpecialOpDenyEdit;

    #ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
    ,eFALSE         // TBOOL                   OutputHold_enable;
    #endif
    #ifdef HMI_SUPPORTS_AUTO_ADJUST
    ,eFALSE         // TBOOL                   AutoAdjustAbort_enable
    #endif
    #ifdef HMI_SUPPORTS_SECONDARY_IDENTIFIER
    ,eFALSE         // TBOOL                   SecondaryIdentifier_Enable;
    #endif
    #ifdef HMI_SUPPORTS_MANUAL_ADJUST_MODIFIER
    ,0              // TUSIGN8                 ManualAdjustModifier;
    #endif
    #ifdef HMI_SUPPORTS_SEQUENCES
    ,eFALSE         // TBOOL                   SequentialMenuEnable;
    #endif
    #ifdef HMI_SUPPORTS_MANUAL_VALVE_CAL
    ,eFALSE         // TBOOL                   ManualValveCalEnable;
    #endif
    #ifdef HMI_SUPPORTS_CONFIG_CHANGE_COUNTER
    ,eFALSE         // TBOOL                   ConfigChangeCounter_enable;
    #endif
    #ifdef HMI_SUPPORTS_AUTO_CALIBRATION
    ,eFALSE         // TBOOL                   NavigationFromAutoCalAllowed;
    ,eFALSE         // TBOOL                   AutoCalRenamed;
    ,eFALSE         // TBOOL                   AutoCalSettlingRemoved;
    #endif
    #ifdef HMI_SUPPORTS_MANUAL_CALIBRATION
    ,eFALSE         // TBOOL                   SampleCollectionEnabled;
    #endif
    #ifdef DISPLAY_DIAGNOSIS_CONDITION_DETAILS
    ,eFALSE         // TBOOL                   DiagDetailsViewActive;
    ,0              // TUSIGN8                 DiagDetailsCursor;
    #endif
};

FRAME_TABLE_LOCAL_TYPE  FrameTableLocal_2 = {
     NULL           // FRAME_FORMAT_TYPE const *currentFrame
    ,0              // TUSIGN8                 editEnabled
    ,0              // TUSIGN8                 cursorPosition
    ,0              // TUSIGN8                 cursorPositionLimit
    ,eTRUE          // TBOOL                   autoscroll
    ,eFALSE         // TBOOL                   nvTestFrameActive
    ,STARTINGFRAME  // FRAME_FORMAT_TYPE const *startupFrame
    ,eFALSE         // TBOOL                   SpecialOpDenyEdit;

    #ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
    ,eFALSE         // TBOOL                   OutputHold_enable;
    #endif
    #ifdef HMI_SUPPORTS_AUTO_ADJUST
    ,eFALSE         // TBOOL                   AutoAdjustAbort_enable
    #endif
    #ifdef HMI_SUPPORTS_SECONDARY_IDENTIFIER
    ,eFALSE         // TBOOL                   SecondaryIdentifier_Enable;
    #endif
    #ifdef HMI_SUPPORTS_MANUAL_ADJUST_MODIFIER
    ,0              // TUSIGN8                 ManualAdjustModifier;
    #endif
    #ifdef HMI_SUPPORTS_SEQUENCES
    ,eFALSE         // TBOOL                   SequentialMenuEnable;
    #endif
    #ifdef HMI_SUPPORTS_MANUAL_VALVE_CAL
    ,eFALSE         // TBOOL                   ManualValveCalEnable;
    #endif
    #ifdef HMI_SUPPORTS_CONFIG_CHANGE_COUNTER
    ,eFALSE         // TBOOL                   ConfigChangeCounter_enable;
    #endif
    #ifdef HMI_SUPPORTS_AUTO_CALIBRATION
    ,eFALSE         // TBOOL                   NavigationFromAutoCalAllowed;
    ,eFALSE         // TBOOL                   AutoCalRenamed;
    ,eFALSE         // TBOOL                   AutoCalSettlingRemoved;
    #endif
    #ifdef HMI_SUPPORTS_MANUAL_CALIBRATION
    ,eFALSE         // TBOOL                   SampleCollectionEnabled
    #endif
    #ifdef DISPLAY_DIAGNOSIS_CONDITION_DETAILS
    ,eFALSE         // TBOOL                   DiagDetailsViewActive;
    ,0              // TUSIGN8                 DiagDetailsCursor;
    #endif
};

#pragma diag_default=Pm023
#pragma diag_default=Pm022

FRAME_TABLE_LOCAL_TYPE  *pFrameTableLocal = &FrameTableLocal_1;

#define LOCAL_currentFrame          pFrameTableLocal->currentFrame
#define LOCAL_editEnabled           pFrameTableLocal->editEnabled
#define LOCAL_cursorPosition        pFrameTableLocal->cursorPosition
#define LOCAL_cursorPositionLimit   pFrameTableLocal->cursorPositionLimit
#define LOCAL_autoscroll            pFrameTableLocal->autoscroll
#define LOCAL_nvTestFrameActive     pFrameTableLocal->nvTestFrameActive
#define LOCAL_RequestedARMLevel     pFrameTableLocal->RequestedARMLevel
#define LOCAL_operatorFrameActive   pFrameTableLocal->operatorFrameActive
#define LOCAL_startupFrame          pFrameTableLocal->startupFrame
#define LOCAL_SpecialOpDenyEdit     pFrameTableLocal->SpecialOpDenyEdit


#ifdef HMI_SUPPORTS_EASYSETUP
#define LOCAL_easySetup_lastStage   pFrameTableLocal->easySetup_lastStage
#define LOCAL_easySetup_actualStage pFrameTableLocal->easySetup_actualStage
#endif

#define LOCAL_menuPosnCursor        pFrameTableLocal->menuPosnCursor
#define LOCAL_menuPosnCursorLim     pFrameTableLocal->menuPosnCursorLim

#if defined (TYPE_4_IMPLEMENTATION) || defined (TYPE_5_IMPLEMENTATION)
#define LOCAL_nValidItems           pFrameTableLocal->nValidItems
#define LOCAL_selectedValidItem     pFrameTableLocal->selectedValidItem
#endif

#ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
#define LOCAL_OutputHold_enable         pFrameTableLocal->OutputHold_enable
#define LOCAL_OutputHoldState_ssIdx     pFrameTableLocal->OutputHoldState_ssIdx
#define LOCAL_OutputHoldState_objIdx    pFrameTableLocal->OutputHoldState_objIdx
#define LOCAL_OutputHoldState_attIdx    pFrameTableLocal->OutputHoldState_attIdx
#endif

#ifdef HMI_SUPPORTS_AUTO_ADJUST
#define LOCAL_AutoAdjustAbort_enable    pFrameTableLocal->AutoAdjustAbort_enable
#define LOCAL_AutoAdjustAbort_ssIdx     pFrameTableLocal->AutoAdjustAbort_ssIdx
#define LOCAL_AutoAdjustAbort_objIdx    pFrameTableLocal->AutoAdjustAbort_objIdx
#define LOCAL_AutoAdjustAbort_attIdx    pFrameTableLocal->AutoAdjustAbort_attIdx
#endif


#ifdef HMI_SUPPORTS_SECONDARY_IDENTIFIER
#define LOCAL_SecondaryIdentifier_Enable    pFrameTableLocal->SecondaryIdentifier_Enable
#define LOCAL_SecondaryIdentifier_Text      pFrameTableLocal->SecondaryIdentifier_Text
#endif

#ifdef HMI_SUPPORTS_MANUAL_ADJUST_MODIFIER
#define LOCAL_ManualAdjustModifier          pFrameTableLocal->ManualAdjustModifier
#endif

#ifdef HMI_SUPPORTS_AUTO_CALIBRATION
#define LOCAL_NavigationFromAutoCalAllowed  pFrameTableLocal->NavigationFromAutoCalAllowed
#define LOCAL_AutoCalRenamed                pFrameTableLocal->AutoCalRenamed
#define LOCAL_AutoCalSettlingRemoved        pFrameTableLocal->AutoCalSettlingRemoved
#endif

#ifdef HMI_SUPPORTS_MANUAL_CALIBRATION
#define LOCAL_SampleCollectionEnabled       pFrameTableLocal->SampleCollectionEnabled
#endif

#ifdef DISPLAY_DIAGNOSIS_CONDITION_DETAILS
#define LOCAL_DiagDetailsViewActive         pFrameTableLocal->DiagDetailsViewActive
#define LOCAL_DiagDetailsCursor             pFrameTableLocal->DiagDetailsCursor
#endif

#define LOCAL_NumericCharacterSetAllowSpace pFrameTableLocal->NumericCharacterSetAllowSpace
#define LOCAL_NumericCharacterSetMinValid   pFrameTableLocal->NumericCharacterSetMinValid
#define LOCAL_NumericCharacterSetMaxValid   pFrameTableLocal->NumericCharacterSetMaxValid

#ifdef HMI_SUPPORTS_TIME_DATE_PARAM_FRAMES
#define LOCAL_TimeDurationLimit             pFrameTableLocal->TimeDurationLimit
#endif

#ifdef HMI_SUPPORTS_SEQUENCES
#define LOCAL_SequentialMenuEnable          pFrameTableLocal->SequentialMenuEnable
#define LOCAL_SequentialMenuPosnCursor      pFrameTableLocal->SequentialMenuPosnCursor
#define LOCAL_SequentialMenuPosnCursorLim   pFrameTableLocal->SequentialMenuPosnCursorLim
#define LOCAL_SequentialMenuTableOffset     pFrameTableLocal->SequentialMenuTableOffset
#endif

#ifdef HMI_SUPPORTS_MANUAL_VALVE_CAL
#define LOCAL_ManualValveCalEnable          pFrameTableLocal->ManualValveCalEnable
#endif

#ifdef HMI_SUPPORTS_CONFIG_CHANGE_COUNTER
#define LOCAL_ConfigChangeCounter_enable    pFrameTableLocal->ConfigChangeCounter_enable
#define LOCAL_ConfigChangeCounter_ssIdx     pFrameTableLocal->ConfigChangeCounter_ssIdx
#define LOCAL_ConfigChangeCounter_obIdx     pFrameTableLocal->ConfigChangeCounter_obIdx
#define LOCAL_ConfigChangeCounter_atIdx     pFrameTableLocal->ConfigChangeCounter_atIdx
#endif

#ifdef HMI_USES_INDIRECT_TEXT
#define LOCAL_derivedString                 pFrameTableLocal->derivedString
#endif

#if defined(HMI_SUPPORTS_WAVEFORM_FRAMES) || defined(HMI_SUPPORTS_MATRIX_FRAMES) || defined(HMI_SUPPORTS_LINEARIZER_FRAMES)
#define LOCAL_inherentNumericFrame          pFrameTableLocal->inherentNumericFrame
#endif

#ifdef HMI_SUPPORTS_MATRIX_FRAMES
#define LOCAL_matrixColumn                  pFrameTableLocal->matrixColumn
#define LOCAL_matrixRow                     pFrameTableLocal->matrixRow
#define LOCAL_matrixCursor                  pFrameTableLocal->matrixCursor
#endif

#ifdef HMI_SUPPORTS_LINEARIZER_FRAMES
#define LOCAL_linearizerCursor                      pFrameTableLocal->linearizerCursor
#define LOCAL_linearizerPoint                       pFrameTableLocal->linearizerPoint
#define LOCAL_linearizerProcessValueDisplay_Enabled pFrameTableLocal->linearizerProcessValueDisplay_Enabled
#define LOCAL_linearizerInpointCapture_Enabled      pFrameTableLocal->linearizerInpointCapture_Enabled
#define LOCAL_linearizerInpointEdit_Enabled         pFrameTableLocal->linearizerInpointEdit_Enabled
#define LOCAL_linearizerOutpointEdit_Enabled        pFrameTableLocal->linearizerOutpointEdit_Enabled
#define LOCAL_linearizerPointEnableDisable_Enabled  pFrameTableLocal->linearizerPointEnableDisable_Enabled
#define LOCAL_linearizerPoint_max                   pFrameTableLocal->linearizerPoint_max
#endif

#ifdef ENUM_ACCELERATOR
#define LOCAL_EnumAccellerator              pFrameTableLocal->EnumAccellerator
#endif

#ifdef STRING_ACCELERATOR
#define LOCAL_StringAccellerator            pFrameTableLocal->StringAccellerator
#endif

#ifdef IPADDR_ACCELERATOR
#define LOCAL_IPAddrAccellerator            pFrameTableLocal->IPAddrAccellerator
#endif

#ifdef DATE_TIME_ACCELERATOR
#define LOCAL_DateTimeAccellerator          pFrameTableLocal->DateTimeAccellerator
#endif

#ifdef MANUAL_ADJUST_ACCELERATOR
#define LOCAL_ManAdjAccellerator            pFrameTableLocal->ManAdjAccellerator
#define LOCAL_ManAdjMaxAccelleratorStage    pFrameTableLocal->ManAdjMaxAccelleratorStage
#define LOCAL_ManAdjBargraphValueCharacters pFrameTableLocal->ManAdjBargraphValueCharacters
#define LOCAL_ManAdjBargraphValuePrecision  pFrameTableLocal->ManAdjBargraphValuePrecision
#endif

#ifndef DISABLE_BACK_MOVE_SELECT
#define LOCAL_mostRecentStandardMenu        pFrameTableLocal->mostRecentStandardMenu
#endif

#else

#define LOCAL_currentFrame          currentFrame
#define LOCAL_editEnabled           editEnabled
#define LOCAL_cursorPosition        cursorPosition
#define LOCAL_cursorPositionLimit   cursorPositionLimit
#define LOCAL_autoscroll            autoscroll
#define LOCAL_nvTestFrameActive     nvTestFrameActive
#define LOCAL_RequestedARMLevel     RequestedARMLevel
#define LOCAL_operatorFrameActive   operatorFrameActive
#define LOCAL_startupFrame          startupFrame
#define LOCAL_SpecialOpDenyEdit     SpecialOpDenyEdit


#ifdef HMI_SUPPORTS_EASYSETUP
#define LOCAL_easySetup_lastStage   easySetup_lastStage
#define LOCAL_easySetup_actualStage easySetup_actualStage
#endif

#define LOCAL_menuPosnCursor        menuPosnCursor
#define LOCAL_menuPosnCursorLim     menuPosnCursorLim

#if defined (TYPE_4_IMPLEMENTATION) || defined (TYPE_5_IMPLEMENTATION)
#define LOCAL_nValidItems           nValidItems
#define LOCAL_selectedValidItem     selectedValidItem
#endif

#ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
#define LOCAL_OutputHold_enable         OutputHold_enable
#define LOCAL_OutputHoldState_ssIdx     OutputHoldState_ssIdx
#define LOCAL_OutputHoldState_objIdx    OutputHoldState_objIdx
#define LOCAL_OutputHoldState_attIdx    OutputHoldState_attIdx
#endif

#ifdef HMI_SUPPORTS_AUTO_ADJUST
#define LOCAL_AutoAdjustAbort_enable    AutoAdjustAbort_enable
#define LOCAL_AutoAdjustAbort_ssIdx     AutoAdjustAbort_ssIdx
#define LOCAL_AutoAdjustAbort_objIdx    AutoAdjustAbort_objIdx
#define LOCAL_AutoAdjustAbort_attIdx    AutoAdjustAbort_attIdx
#endif

#ifdef HMI_SUPPORTS_SECONDARY_IDENTIFIER
#define LOCAL_SecondaryIdentifier_Enable    SecondaryIdentifier_Enable
#define LOCAL_SecondaryIdentifier_Text      SecondaryIdentifier_Text
#endif

#ifdef HMI_SUPPORTS_MANUAL_ADJUST_MODIFIER
#define LOCAL_ManualAdjustModifier          ManualAdjustModifier
#endif

#ifdef HMI_SUPPORTS_AUTO_CALIBRATION
#define LOCAL_NavigationFromAutoCalAllowed  NavigationFromAutoCalAllowed
#define LOCAL_AutoCalRenamed                AutoCalRenamed
#define LOCAL_AutoCalSettlingRemoved        AutoCalSettlingRemoved
#endif

#ifdef HMI_SUPPORTS_MANUAL_CALIBRATION
#define LOCAL_SampleCollectionEnabled       SampleCollectionEnabled
#endif

#ifdef DISPLAY_DIAGNOSIS_CONDITION_DETAILS
#define LOCAL_DiagDetailsViewActive         DiagDetailsViewActive
#define LOCAL_DiagDetailsCursor             DiagDetailsCursor
#endif

#ifdef HMI_SUPPORTS_TIME_DATE_PARAM_FRAMES
#define LOCAL_TimeDurationLimit             TimeDurationLimit
#endif

#ifdef HMI_SUPPORTS_SEQUENCES
#define LOCAL_SequentialMenuEnable          SequentialMenuEnable
#define LOCAL_SequentialMenuPosnCursor      SequentialMenuPosnCursor
#define LOCAL_SequentialMenuPosnCursorLim   SequentialMenuPosnCursorLim
#define LOCAL_SequentialMenuTableOffset     SequentialMenuTableOffset
#endif

#ifdef HMI_SUPPORTS_MANUAL_VALVE_CAL
#define LOCAL_ManualValveCalEnable          ManualValveCalEnable
#endif

#ifdef HMI_SUPPORTS_CONFIG_CHANGE_COUNTER
#define LOCAL_ConfigChangeCounter_enable    ConfigChangeCounter_enable
#define LOCAL_ConfigChangeCounter_ssIdx     ConfigChangeCounter_ssIdx
#define LOCAL_ConfigChangeCounter_obIdx     ConfigChangeCounter_obIdx
#define LOCAL_ConfigChangeCounter_atIdx     ConfigChangeCounter_atIdx
#endif

#ifdef HMI_USES_INDIRECT_TEXT
#define LOCAL_derivedString                 derivedString
#endif

#if defined(HMI_SUPPORTS_WAVEFORM_FRAMES) || defined(HMI_SUPPORTS_MATRIX_FRAMES) || defined(HMI_SUPPORTS_LINEARIZER_FRAMES)
#define LOCAL_inherentNumericFrame          inherentNumericFrame
#endif

#ifdef HMI_SUPPORTS_MATRIX_FRAMES
#define LOCAL_matrixColumn                  matrixColumn
#define LOCAL_matrixRow                     matrixRow
#define LOCAL_matrixCursor                  matrixCursor
#endif

#ifdef HMI_SUPPORTS_LINEARIZER_FRAMES
#define LOCAL_linearizerCursor                      linearizerCursor
#define LOCAL_linearizerPoint                       linearizerPoint
#define LOCAL_linearizerProcessValueDisplay_Enabled linearizerProcessValueDisplay_Enabled
#define LOCAL_linearizerInpointCapture_Enabled      linearizerInpointCapture_Enabled
#define LOCAL_linearizerInpointEdit_Enabled         linearizerInpointEdit_Enabled
#define LOCAL_linearizerOutpointEdit_Enabled        linearizerOutpointEdit_Enabled
#define LOCAL_linearizerPointEnableDisable_Enabled  linearizerPointEnableDisable_Enabled
#define LOCAL_linearizerPoint_max                   linearizerPoint_max
#endif

#ifdef ENUM_ACCELERATOR
#define LOCAL_EnumAccellerator              EnumAccellerator
#endif

#ifdef STRING_ACCELERATOR
#define LOCAL_StringAccellerator            StringAccellerator
#endif

#ifdef IPADDR_ACCELERATOR
#define LOCAL_IPAddrAccellerator            IPAddrAccellerator
#endif

#ifdef DATE_TIME_ACCELERATOR
#define LOCAL_DateTimeAccellerator          DateTimeAccellerator
#endif

#ifdef MANUAL_ADJUST_ACCELERATOR
#define LOCAL_ManAdjAccellerator            ManAdjAccellerator
#define LOCAL_ManAdjMaxAccelleratorStage    ManAdjMaxAccelleratorStage
#define LOCAL_ManAdjBargraphValueCharacters ManAdjBargraphValueCharacters
#define LOCAL_ManAdjBargraphValuePrecision  ManAdjBargraphValuePrecision
#endif

#ifndef DISABLE_BACK_MOVE_SELECT
#define LOCAL_mostRecentStandardMenu        mostRecentStandardMenu
#endif

#define LOCAL_NumericCharacterSetAllowSpace NumericCharacterSetAllowSpace
#define LOCAL_NumericCharacterSetMinValid   NumericCharacterSetMinValid
#define LOCAL_NumericCharacterSetMaxValid   NumericCharacterSetMaxValid



FRAME_FORMAT_TYPE const *currentFrame = NULL;
TUSIGN8                 editEnabled = 0;
TUSIGN8                 cursorPosition = 0;
TUSIGN8                 cursorPositionLimit = 0;
TBOOL                   autoscroll = eTRUE;
TBOOL                   nvTestFrameActive = eFALSE;
TUSIGN8                 RequestedARMLevel;
TBOOL                   operatorFrameActive;
FRAME_FORMAT_TYPE const *startupFrame = STARTINGFRAME;
TBOOL                   SpecialOpDenyEdit = eFALSE;

#ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
TBOOL                   OutputHold_enable = eFALSE;
#endif

#ifdef HMI_SUPPORTS_AUTO_ADJUST
TBOOL                   AutoAdjustAbort_enable = eFALSE;
#endif

#ifdef HMI_SUPPORTS_SECONDARY_IDENTIFIER
TBOOL                   SecondaryIdentifier_Enable = eFALSE;
TUSIGN8                 SecondaryIdentifier_Text[SECONDARY_IDENTIFIER_LEN];
#endif

#ifdef HMI_SUPPORTS_MANUAL_ADJUST_MODIFIER
TUSIGN8                 ManualAdjustModifier = 0;
#endif

#ifdef HMI_SUPPORTS_TIME_DATE_PARAM_FRAMES
TUSIGN32                TimeDurationLimit;
#endif

#ifdef HMI_SUPPORTS_SEQUENCES
TBOOL                   SequentialMenuEnable = eFALSE;
TUSIGN8                 SequentialMenuPosnCursor;
TUSIGN8                 SequentialMenuPosnCursorLim;
TUSIGN16                SequentialMenuTableOffset;
#endif

#ifdef HMI_SUPPORTS_MANUAL_VALVE_CAL
TBOOL                   ManualValveCalEnable = eFALSE;
#endif

#ifdef HMI_SUPPORTS_AUTO_CALIBRATION
TBOOL                   NavigationFromAutoCalAllowed = eFALSE;
TBOOL                   AutoCalRenamed = eFALSE;
TBOOL                   AutoCalSettlingRemoved = eFALSE;
#endif

#ifdef HMI_SUPPORTS_MANUAL_CALIBRATION
TBOOL                   SampleCollectionEnabled = eFALSE;
#endif

#ifdef DISPLAY_DIAGNOSIS_CONDITION_DETAILS
TBOOL                   DiagDetailsViewActive = eFALSE;
TUSIGN8                 DiagDetailsCursor = 0;
#endif

#ifdef HMI_SUPPORTS_CONFIG_CHANGE_COUNTER
TBOOL                   ConfigChangeCounter_enable = eFALSE;
TUSIGN16                ConfigChangeCounter_ssIdx;
TUSIGN16                ConfigChangeCounter_obIdx;
TINT16                  ConfigChangeCounter_atIdx;
#endif

#ifdef ENUM_ACCELERATOR
TUSIGN8 EnumAccellerator;
#endif

#ifdef STRING_ACCELERATOR
TUSIGN8 StringAccellerator;
#endif

#ifdef IPADDR_ACCELERATOR
TUSIGN8 IPAddrAccellerator;
#endif

#ifdef DATE_TIME_ACCELERATOR
TUSIGN8 DateTimeAccellerator;
#endif

#ifdef MANUAL_ADJUST_ACCELERATOR
TUSIGN8 ManAdjAccellerator;
TUSIGN8 ManAdjMaxAccelleratorStage;
TUSIGN8 ManAdjBargraphValueCharacters;
TUSIGN8 ManAdjBargraphValuePrecision;
#endif

#ifndef DISABLE_BACK_MOVE_SELECT
FRAME_FORMAT_TYPE const *mostRecentStandardMenu;
#endif

#ifdef HMI_SUPPORTS_EASYSETUP
TUSIGN8                 easySetup_lastStage;
TUSIGN8                 easySetup_actualStage;
#endif

TUSIGN8                 menuPosnCursor;
TUSIGN8                 menuPosnCursorLim;

#if defined (TYPE_4_IMPLEMENTATION) || defined (TYPE_5_IMPLEMENTATION)
TUSIGN8                 nValidItems;
TUSIGN8                 selectedValidItem;
#endif

#ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
TUSIGN8                 OutputHoldState_ssIdx;
TUSIGN8                 OutputHoldState_objIdx;
TUSIGN8                 OutputHoldState_attIdx;
#endif

#ifdef HMI_SUPPORTS_AUTO_ADJUST
TUSIGN8                 AutoAdjustAbort_ssIdx;
TUSIGN8                 AutoAdjustAbort_objIdx;
TUSIGN8                 AutoAdjustAbort_attIdx;
#endif

#ifdef HMI_USES_INDIRECT_TEXT
TUSIGN8 FAST                derivedString[21];
#endif

#if defined(HMI_SUPPORTS_WAVEFORM_FRAMES) || defined(HMI_SUPPORTS_MATRIX_FRAMES) || defined(HMI_SUPPORTS_LINEARIZER_FRAMES)
FRAME_FORMAT_TYPE       inherentNumericFrame;
#endif


#ifdef HMI_SUPPORTS_MATRIX_FRAMES
TUSIGN8                 matrixColumn;
TUSIGN8                 matrixRow;
MATRIX_CURSOR_POS       matrixCursor;
#endif

#ifdef HMI_SUPPORTS_LINEARIZER_FRAMES
LINEARIZER_CURSOR_POS   linearizerCursor;
TUSIGN8                 linearizerPoint;
TBOOL                   linearizerProcessValueDisplay_Enabled;
TBOOL                   linearizerInpointCapture_Enabled;
TBOOL                   linearizerInpointEdit_Enabled;
TBOOL                   linearizerOutpointEdit_Enabled;
TBOOL                   linearizerPointEnableDisable_Enabled;
TUSIGN8                 linearizerPoint_max;
#endif

TBOOL                   NumericCharacterSetAllowSpace;
TUSIGN8                 NumericCharacterSetMinValid;
TUSIGN8                 NumericCharacterSetMaxValid;

#endif


#ifdef HMI_SUPPORTS_CUSTOM_UNITS
TUSIGN8 CustomUnitString_1[19];
TUSIGN8 CustomUnitString_2[19];
TUSIGN8 CustomUnitString_3[19];
TUSIGN8 CustomUnitString_4[19];
TUSIGN8 CustomUnitString_5[19];
TUSIGN8 CustomUnitString_6[19];
TUSIGN8 CustomUnitString_7[19];
TUSIGN8 CustomUnitString_8[19];
TUSIGN8 CustomUnitString_9[19];
TUSIGN8 CustomUnitString_10[19];
TUSIGN8 CustomUnitString_11[19];
#endif

#ifdef HMI_SUPPORTS_WAVEFORM_FRAMES
TUSIGN8                 WaveformsToInitialise = MAX_WAVEFORMS;
TUSIGN8                 waveformPRVindex[MAX_WAVEFORMS];
TUSIGN8                 waveformCRVindex[MAX_WAVEFORMS];
WAVEFORM_CURSOR_POS     waveformCursor[MAX_WAVEFORMS];
TBOOL                   waveformCursorChange[MAX_WAVEFORMS];
TBOOL                   waveformEditStateChange[MAX_WAVEFORMS];
#endif

#ifdef HMI_SUPPORTS_MATRIX_FRAMES
TBOOL Setup_Matrix_NumericFrame(MATRIX_CURSOR_POS cursorPos);
void Initialise_MatrixData(FRAME_FORMAT_TYPE const *pMatrixFrame);
#endif

#ifdef HMI_SUPPORTS_LINEARIZER_FRAMES
TBOOL Setup_Linearizer_NumericFrame(LINEARIZER_CURSOR_POS cursorPos);
void Initialise_LinearizerData(FRAME_FORMAT_TYPE const *pLinearizerFrame);
#endif


#if defined (HMI_MODULE_TEST) && defined(HMI_MODULE_TEST_FRAMEMOVER)
FRAME_FORMAT_TYPE *firstConfigHeader;
FRAME_FORMAT_TYPE *lastConfigHeader;
#endif

#ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
void SetOutputHold(TUSIGN8 HoldValue);
#endif

#ifdef HMI_SUPPORTS_CUSTOM_UNITS
void GetCustomUnitString(TUSIGN8 UnitNumber);
#endif

const TUSIGN8 *GetString(TEXT_IDENTIFIER_TYPE id, TUSIGN8 language);

#if defined(COMMON_TOP_WORKS_NEW_FEATURES) && defined(HMI_USES_CUSTOM_LANGUAGES)
TUSIGN8 checkForCustomLanguage(TUSIGN8 stringTableID);
#define CUSTOM_LANGUAGE_STRING_TABLE 20
#endif

#ifdef HMI_SUPPORTS_SERVICEPORT
// No restriction on the optimization of this function
void FrameTableSetLocalDataPointer(TUSIGN8 newInstance)
{
    if      (newInstance == 1)  {pFrameTableLocal = &FrameTableLocal_1;}
    else if (newInstance == 2)  {pFrameTableLocal = &FrameTableLocal_2;}
    else                        {assert(0);}
}
#endif

#ifdef LEFT_RIGHT_LOCKOUT

TUSIGN8  prvLeftRightLockoutState = WRONG_KEY_PRESSED;
TUSIGN8  LeftRightLockoutState = WRONG_KEY_PRESSED;
TUSIGN16 LeftRightLockoutTimer = 0;
TBOOL    LeftRightLockoutEnable = eTRUE;

void FrameTableSetFunctionKeyLock(TBOOL lockState)
{
    LeftRightLockoutEnable = lockState;
}

TUSIGN8 FrameTableGetLeftRightLockoutState(void)
{
    TUSIGN8 returnVal = LEFT_RIGHT_ENABLED;

    if (LeftRightLockoutEnable)
    {
        returnVal = LeftRightLockoutState;

        #ifdef HMI_SUPPORTS_SERVICEPORT
        if (pFrameTableLocal == &FrameTableLocal_2)
        {
            returnVal = LEFT_RIGHT_ENABLED;
        }
        #endif
    }

    return returnVal;
}

TBOOL FrameTableGetLeftRightLockout(void)
{
    TBOOL returnVal = eFALSE;

    if (LeftRightLockoutEnable)
    {
        #ifdef HMI_SUPPORTS_SERVICEPORT
        if (pFrameTableLocal != &FrameTableLocal_2)
        #endif
        {
            if ((LeftRightLockoutState != NOT_OPERATOR_PAGE) && (LeftRightLockoutState != LEFT_RIGHT_ENABLED))
            {
                returnVal = eTRUE;
            }
        }
    }
    return returnVal;
}

void FrameTableUpdateLeftRightLockout(TUSIGN8 keyState)
{
    if (LeftRightLockoutEnable)
    {
        #ifdef HMI_SUPPORTS_SERVICEPORT
        if (pFrameTableLocal != &FrameTableLocal_2)
        #endif
        {
            if (keyState == KEYSTATE_AUTOSCROLL)
            {
                keyState = KEYSTATE_NONE;
            }

            if (LOCAL_currentFrame->frameType != FRAME_TYPE_OPERATOR)
            {
                LeftRightLockoutState = NOT_OPERATOR_PAGE;
                LeftRightLockoutTimer = 0;
            }
            else
            {
                if (prvLeftRightLockoutState == NOT_OPERATOR_PAGE)
                {
                    LeftRightLockoutState = LEFT_RIGHT_ENABLED;
                }

                switch (LeftRightLockoutState)
                {
                case WRONG_KEY_PRESSED:
                    if (keyState == KEYSTATE_NONE)
                    {
                        LeftRightLockoutState = NO_KEY_PRESSED;
                        LeftRightLockoutTimer = 0;
                    }
                    break;

                case NO_KEY_PRESSED:
                    if (keyState != KEYSTATE_NONE)
                    {
                        LeftRightLockoutState = WRONG_KEY_PRESSED;
                    }
                    else
                    {
                        LeftRightLockoutTimer ++;

                        if (LeftRightLockoutTimer > (HMI_DISPLAY_RATE_CYCLES))
                        {
                            LeftRightLockoutState = LOOKING_FOR_UP;
                        }
                    }
                    break;

                case LOOKING_FOR_UP:
                    if (keyState != KEYSTATE_NONE)
                    {
                        if (keyState == KEYSTATE_DOWN)
                        {
                            LeftRightLockoutState = LOOKING_FOR_UP_AND_DOWN;
                            LeftRightLockoutTimer = 0;

                        }
                        else if ((keyState == KEYSTATE_UP) || (keyState == KEYSTATE_UP_AND_DOWN))
                        {
                            LeftRightLockoutState = UP_KEY_ACTIVE;
                            LeftRightLockoutTimer = 0;
                        }
                        else
                        {
                            LeftRightLockoutState = WRONG_KEY_PRESSED;
                        }
                    }
                    break;

                case LOOKING_FOR_UP_AND_DOWN:
                    if ((keyState == KEYSTATE_UP) || (keyState == KEYSTATE_UP_AND_DOWN))
                    {
                        LeftRightLockoutState = UP_KEY_ACTIVE;
                    }
                    else if (keyState == KEYSTATE_DOWN)
                    {
                        LeftRightLockoutTimer += 4;
                        if (LeftRightLockoutTimer > HMI_DISPLAY_RATE_CYCLES)
                        {
                            LeftRightLockoutState = WRONG_KEY_PRESSED;
                        }
                    }
                    else if (keyState == KEYSTATE_NONE)
                    {
                        LeftRightLockoutState = NO_KEY_PRESSED;
                        LeftRightLockoutTimer = 0;
                    }
                    else
                    {
                        LeftRightLockoutState = WRONG_KEY_PRESSED;
                    }
                    break;


                case UP_KEY_ACTIVE:
                    if ((keyState == KEYSTATE_UP) || (keyState == KEYSTATE_UP_AND_DOWN))
                    {
                        LeftRightLockoutTimer +=2;

                        if (LeftRightLockoutTimer > HMI_DISPLAY_RATE_CYCLES)
                        {
                           LeftRightLockoutState = LEFT_RIGHT_ENABLED;
                           LeftRightLockoutTimer = 0;
                        }
                    }
                    else if (keyState == KEYSTATE_NONE)
                    {
                        LeftRightLockoutState = NO_KEY_PRESSED;
                        LeftRightLockoutTimer = 0;
                    }
                    else
                    {
                        LeftRightLockoutState = WRONG_KEY_PRESSED;
                    }

                    break;

                case LEFT_RIGHT_ENABLED:
                    #if defined(HMI_SUPPORTS_SECURITY_ACCESS) && defined(OVERRIDE_LR_LOCKOUT_WHILST_LOGGED_IN)

                    if (AdjusterGetARMLevel() != ARM_ACCESS_READ_ONLY)
                    {
                        LeftRightLockoutTimer = 0;
                    }

                    #endif

                    if ((keyState == KEYSTATE_UP) || (keyState == KEYSTATE_UP_AND_DOWN))
                    {
                        LeftRightLockoutTimer += 4;

                        if (LeftRightLockoutTimer > (5 * HMI_DISPLAY_RATE_CYCLES))
                        {
                           LeftRightLockoutState = WRONG_KEY_PRESSED;
                           LeftRightLockoutTimer = 0;
                        }
                    }
                    else if (keyState == KEYSTATE_NONE)
                    {
                        LeftRightLockoutTimer ++;

                        if (LeftRightLockoutTimer > (5 * HMI_DISPLAY_RATE_CYCLES))
                        {
                           LeftRightLockoutState = NO_KEY_PRESSED;
                           LeftRightLockoutTimer = 0;
                        }
                    }
                    else if ((keyState != KEYSTATE_RIGHT) && (keyState != KEYSTATE_LEFT))
                    {
                        LeftRightLockoutState = WRONG_KEY_PRESSED;
                    }
                    else
                    {
                        asm("nop");
                    }
                    break;

                default:
                    LeftRightLockoutState = WRONG_KEY_PRESSED;
                    break;
                }

            }
            prvLeftRightLockoutState = LeftRightLockoutState;
        }
    }
}
#endif

//#ifdef SUPPORT_SHMI
void GetStrLibVer(TUSIGN8* pStrLibVer, TUSIGN8* pStdLibVer)
{
    *pStrLibVer = LIB_STRING_VERSION_VT5;
    *pStdLibVer = LIB_STRING_VERSION_STD;
}
//#endif

TBOOL FrameTableIsOperatorFrameActive(TUSIGN8 instance)
{
    TBOOL returnVal = eTRUE;    // assume operator view

    #ifdef HMI_SUPPORTS_SERVICEPORT
        if (instance == HMI_LOCAL_INSTANCE)
        {
            returnVal = FrameTableLocal_1.operatorFrameActive;
        }
        else if (instance == HMI_REMOTE_INSTANCE)
        {
            returnVal = FrameTableLocal_2.operatorFrameActive;
        }
        else
        {
            returnVal = eTRUE;
        }
    #else
        if (instance == HMI_LOCAL_INSTANCE)
        {
            returnVal = operatorFrameActive;
        }
    #endif

    return returnVal;
}

/*!
 \brief         Tells the HMI that NV initilaization has terminated.
 \author        Roger Arnold
 \test          No details available
*/
void FrameTableNVInitComplete(void)
{
#ifdef HMI_SUPPORTS_SERVICEPORT

    FRAME_TABLE_LOCAL_TYPE *tempLocalDatapointer = pFrameTableLocal;

    pFrameTableLocal = &FrameTableLocal_1;
    LOCAL_nvTestFrameActive = eFALSE;
    FrameTableInitialise(LOCAL_nvTestFrameActive);

    pFrameTableLocal = &FrameTableLocal_2;
    LOCAL_nvTestFrameActive = eFALSE;
    FrameTableInitialise(LOCAL_nvTestFrameActive);

    pFrameTableLocal = tempLocalDatapointer;
#else
    LOCAL_nvTestFrameActive = eFALSE;
    FrameTableInitialise(LOCAL_nvTestFrameActive);
#endif
}

/*!
 \brief         Tells the HMI that NV initilaization has terminated.
 \author        Roger Arnold
 \return	    the NVinit frame status (eTRUE = active, eFALSE = inactive)
 \test          No details available
*/
TBOOL FrameTableIsNVInitActive(void)
{
    return LOCAL_nvTestFrameActive;
}


#ifdef LOW_LEVEL_HMI_TEST
#pragma diag_suppress=Pm022
__root const FRAME_FORMAT_TYPE LowLevelHMITestFrame=
{
FRAME_TYPE_OPERATOR,
#ifdef HMI_USES_SPECIAL_OP_CODES
IDF_SPECIAL_NONE,
IDF_SPECIAL_NONE,
IDF_SPECIAL_NONE,
#endif
//lint -e{708}
NULL,         // *pNextFrame
0,            // unused_1;
0,            // unused_2;
99,           // frameNumber;
0,0,0,        // Tag;
0,            // tag_type;
0,            // tag_maxCharacters;
0,            // unused_3;
0,            // unused_4;
0,            // unused_5;
#ifdef HMI_SUPPORTS_EASYSETUP
0,            // unused_spare;
#endif
};

FRAME_FORMAT_TYPE const *FrameTableGetLowLevelHMITestFrame(void)
{
    return &LowLevelHMITestFrame;
}

#endif



/*!
 \brief         Initializes the class.
                        1. Sets the stringAddr arrays so that strings can be read from the tables using GetString()
                        2. Sets language to 0 (default)
 \author        Roger Arnold
 \param         none.
 \return        none.
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
void FrameTableInitialise(TBOOL nvTest)
{
#ifdef LOW_LEVEL_HMI_TEST
    (void)FrameTableSetCurrentFrame(&LowLevelHMITestFrame,0,IDF_SPECIAL_NONE);
#else
    #if NVINIT_STYLE > 0
        if (nvTest)
        {
            (void)FrameTableSetCurrentFrame(NVTESTFRAME,0,IDF_SPECIAL_NONE);
            LOCAL_nvTestFrameActive = eTRUE;
        }
        else
        {
            if (LOCAL_currentFrame == NVTESTFRAME)
            {
                (void)FrameTableSetCurrentFrame(LOCAL_startupFrame,0,IDF_SPECIAL_NONE);
            }
        }
    #else
        (void)FrameTableSetCurrentFrame(LOCAL_startupFrame,0,IDF_SPECIAL_NONE);
    #endif
#endif

#ifdef HMI_SUPPORTS_WAVEFORM_FRAMES
    while (WaveformsToInitialise)
    {
        WaveformsToInitialise --;
        waveformPRVindex[WaveformsToInitialise] = 0;
        waveformCRVindex[WaveformsToInitialise] = 0;
        waveformCursor[WaveformsToInitialise] = WAVEFORM_CURSOR_PRC_REL_VAL;
        waveformCursorChange[WaveformsToInitialise] = eTRUE;
        waveformEditStateChange[WaveformsToInitialise] = eTRUE;
    }
#endif
}

#ifdef DISPLAY_DIAGNOSIS_CONDITION_DETAILS

TBOOL FrameTable_isDiagDetailsViewActive(void)
{
    return LOCAL_DiagDetailsViewActive;
}

TUSIGN8 FrameTable_GetDiagDetailsCursor(void)
{
    return LOCAL_DiagDetailsCursor;

}

TUSIGN8 FrameTableActivateDiagDetailsView(TBOOL activate)
{
    TUSIGN8 returnCode = 0;

    if (LOCAL_DiagDetailsViewActive != activate)
    {
        LOCAL_DiagDetailsViewActive = activate;
        LOCAL_DiagDetailsCursor = 0;

        returnCode = 1;
    }
    return returnCode;
}

void FrameTable_nextDiagDetail(TUSIGN8 up)
{
    if (up)
    {
        // up button pressed - moving down list
        if (LOCAL_DiagDetailsCursor > 0)
        {
            LOCAL_DiagDetailsCursor --;
        }
    }
    else
    {
        // down button pressed - moving up list
        // The cursor limit is the number of details minus 2
        // ..minus 2 because the display shows 3 lines - details at cursor
        //                                               details at cursor + 1
        //                                               details at cursor + 1
        if (LOCAL_DiagDetailsCursor < (Adjuster_GetDiagDetailsViewCursorMax() - 2))
        {
            LOCAL_DiagDetailsCursor ++;
        }
    }
}

#endif // end of #ifdef DISPLAY_DIAGNOSIS_CONDITION_DETAILS

#ifdef HMI_SUPPORTS_LINEARIZER_FRAMES
LINEARIZER_CURSOR_POS FrameTable_GetLinearizerCursor(void)
{
    return LOCAL_linearizerCursor;
}

TBOOL FrameTable_NextLinearizerCursor(void)
{
    TBOOL returnVal = eTRUE;

    switch (LOCAL_linearizerCursor)
    {
    case LINEARIZER_CURSOR_INPOINT_EDIT:        returnVal = eFALSE;                                         break;
    case LINEARIZER_CURSOR_OUTPOINT_EDIT:       returnVal = eFALSE;                                         break;
    case LINEARIZER_CURSOR_EXIT:                LOCAL_linearizerCursor = LINEARIZER_CURSOR_INPOINT_VIEW;    break;
    case LINEARIZER_CURSOR_INPOINT_VIEW:        LOCAL_linearizerCursor = LINEARIZER_CURSOR_OUTPOINT_VIEW;   break;
    case LINEARIZER_CURSOR_OUTPOINT_VIEW:       LOCAL_linearizerCursor = LINEARIZER_CURSOR_EXIT;            break;
    default:                                    LOCAL_linearizerCursor = LINEARIZER_CURSOR_EXIT;            break;
    }
    return returnVal;
}

TUSIGN8 FrameTable_GetLinearizerPoint(void)
{
    return LOCAL_linearizerPoint;
}

void FrameTable_NextLinearizerPoint(TBOOL up)
{
    if (( up) && (LOCAL_linearizerPoint < LOCAL_linearizerPoint_max))  { LOCAL_linearizerPoint ++; }
    if ((!up) && (LOCAL_linearizerPoint > 0))                          { LOCAL_linearizerPoint --; }
}

TBOOL FrameTable_LinearizerEdit(TBOOL enable)
{
    TBOOL returnVal = eFALSE;

    if (enable)
    {
        TBOOL   PointValid = eFALSE;

        ATTRIB_IDENTIFIER_TYPE PointID;
        PointID.ssIdx = (TUSIGN16)(LOCAL_currentFrame->frameDefinition.linearizerFrame.linearizer_subsystem_index);
        PointID.objIdx = 0;
        PointID.attribIdx = LOCAL_linearizerPoint;

        if ((LOCAL_linearizerCursor == LINEARIZER_CURSOR_INPOINT_VIEW)
         && (LOCAL_linearizerInpointEdit_Enabled))
        {
            PointID.objIdx = (TUSIGN16)(LOCAL_currentFrame->frameDefinition.linearizerFrame.inpoint_object_index);
            PointValid = eTRUE;
        }
        else if ((LOCAL_linearizerCursor == LINEARIZER_CURSOR_OUTPOINT_VIEW)
              && (LOCAL_linearizerOutpointEdit_Enabled))
        {
            if (FrameTable_GetLinearizerPointEnable(LOCAL_currentFrame->frameDefinition.linearizerFrame.linearizer_subsystem_index,
                                                    LOCAL_currentFrame->frameDefinition.linearizerFrame.pointEnable_objectIndex,
                                                    LOCAL_linearizerPoint))
            {
                PointID.objIdx = (TUSIGN16)(LOCAL_currentFrame->frameDefinition.linearizerFrame.outpoint_object_index);
                PointValid = eTRUE;
            }
            else
            {
                PointValid = eFALSE;
            }
        }
        else
        {
            PointValid = eFALSE;
        }

        if (PointValid)
        {
            if (WriteProtect_HMICanAccess(PointID, (TUSIGN8)0))
            {
                if (Setup_Linearizer_NumericFrame((LINEARIZER_CURSOR_POS)(LOCAL_linearizerCursor + 1)))
                {
                    LOCAL_linearizerCursor ++;

                    LOCAL_editEnabled = 1;
                    LOCAL_cursorPosition = 0;
                    LOCAL_cursorPositionLimit = 6 + 1;


                    AdjusterPrepareNewVariable(0);
                    AdjusterInitialiseNewVariable((void *)&LOCAL_inherentNumericFrame);

                    returnVal = eTRUE;
                }
            }
        }
    }
    else
    {
        if ((LOCAL_linearizerCursor == LINEARIZER_CURSOR_INPOINT_EDIT)
         || (LOCAL_linearizerCursor == LINEARIZER_CURSOR_OUTPOINT_EDIT))
        {
            LOCAL_linearizerCursor --;
            returnVal = eTRUE;
        }
    }
    return returnVal;
}

TBOOL Setup_Linearizer_NumericFrame(LINEARIZER_CURSOR_POS cursorPos)
{
    TBOOL SuccessfulSetup = eFALSE;
    {
        TBOOL dataValid = eFALSE;
        TUSIGN16 DataSS = LOCAL_currentFrame->frameDefinition.linearizerFrame.linearizer_subsystem_index;
        TUSIGN16 DataObj = 0;
        TINT16   DataAtt = LOCAL_linearizerPoint;

        TUSIGN8 temp_dp;

        switch(cursorPos)
        {
        case LINEARIZER_CURSOR_INPOINT_EDIT:
            DataObj = LOCAL_currentFrame->frameDefinition.linearizerFrame.inpoint_object_index;
            temp_dp = LOCAL_currentFrame->frameDefinition.linearizerFrame.dpPosn_inpoint;
            dataValid = eTRUE;
            break;

        case LINEARIZER_CURSOR_OUTPOINT_EDIT:
            DataObj = LOCAL_currentFrame->frameDefinition.linearizerFrame.outpoint_object_index;
            temp_dp = LOCAL_currentFrame->frameDefinition.linearizerFrame.dpPosn_outpoint;
            dataValid = eTRUE;
            break;

        default:
            dataValid = eFALSE;
            break;
        }

        if ((dataValid)
         && (DataSS  <= 255)
         && (DataObj <= 255)
         && (DataAtt >= 0)
         && (DataAtt <= 99))
        {
            LOCAL_inherentNumericFrame.frameType                                                            = FRAME_TYPE_NUMERICAL_PARAM;
            #ifdef HMI_USES_SPECIAL_OP_CODES
            LOCAL_inherentNumericFrame.specialOpCode[0]                                                     = IDF_SPECIAL_NONE;
            LOCAL_inherentNumericFrame.specialOpCode[1]                                                     = IDF_SPECIAL_NONE;
            LOCAL_inherentNumericFrame.specialOpCode[2]                                                     = IDF_SPECIAL_NONE;
            #endif

            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.pFaultFrame                      = 0;

            // Set up Title Bar & Title fixed text (blank) - These parameters are not used
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.titleBar_attribidx               = IDS_BLANK;
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.title_attribidx                  = IDS_BLANK;

            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.value.ssIdx                      = (TUSIGN8)DataSS;
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.value.objIdx                     = (TUSIGN8)DataObj;
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.value.attribIdx                  = (TUSIGN8)DataAtt;

            // Set up Engineering units as fixed text (blank) - These parameters are not used
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.engUnits.ssIdx                   = 0;            //MatrixSubsystem
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.engUnits.objIdx                  = IDS_BLANK;    //MatrixObject
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.engUnits.attribIdx               = 0;            //0

            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.engUnitsType                     = FIXED_TEXT_UNITS;

            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.attributes.maxCharacters         = 6;
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.attributes.characterSet_dpPosn   = temp_dp;

            #ifdef HMI_SUPPORTS_EASYSETUP
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.easySetupFlag                    = 0;
            #endif

            SuccessfulSetup = eTRUE;
        }
    }
    return SuccessfulSetup;
}

void Initialise_LinearizerData(FRAME_FORMAT_TYPE const *pLinearizerFrame)
{
    LOCAL_linearizerPoint = 0;
    LOCAL_linearizerCursor = LINEARIZER_CURSOR_EXIT;


    TUSIGN16 nInPoints     = 1;
    TUSIGN16 nOutPoints    = 1;
    TUSIGN16 nPointEnables = 1;
    TUSIGN16 nPoints = 1;

    T_DO_OBJECT_DESCRIPTION  objectDescriptor;
    const T_UNIT *pLinearizerSubsystem  = GetSubsystemPtr((TUSIGN16)(pLinearizerFrame->frameDefinition.linearizerFrame.linearizer_subsystem_index));

    if ((TUSIGN16)OK ==  pLinearizerSubsystem->GetObjectDescription(pLinearizerSubsystem,(TUSIGN16)(pLinearizerFrame->frameDefinition.linearizerFrame.inpoint_object_index),&objectDescriptor))
    {
        nInPoints = objectDescriptor.numberOfAttributes;
    }
    if ((TUSIGN16)OK ==  pLinearizerSubsystem->GetObjectDescription(pLinearizerSubsystem,(TUSIGN16)(pLinearizerFrame->frameDefinition.linearizerFrame.outpoint_object_index),&objectDescriptor))
    {
        nOutPoints = objectDescriptor.numberOfAttributes;
    }
    if ((TUSIGN16)OK ==  pLinearizerSubsystem->GetObjectDescription(pLinearizerSubsystem,(TUSIGN16)(pLinearizerFrame->frameDefinition.linearizerFrame.pointEnable_objectIndex),&objectDescriptor))
    {
        nPointEnables = objectDescriptor.numberOfAttributes;
    }

    nPoints = nPointEnables;
    if (nOutPoints < nPoints)   { nPoints = nOutPoints; }
    if (nInPoints  < nPoints)   { nPoints = nInPoints;  }
    if (nPoints > 100)          { nPoints = 100;        }

    LOCAL_linearizerPoint_max = nPoints - 1;
}

TBOOL FrameTable_CaptureLinearizerInputPoint(void)
{
    TBOOL returnVal = eFALSE;

    if ((LOCAL_linearizerInpointCapture_Enabled)
     && (LOCAL_linearizerProcessValueDisplay_Enabled)
     && (LOCAL_currentFrame->frameDefinition.linearizerFrame.ProcessSignal != 0xFF))
    {
        ATTRIB_IDENTIFIER_TYPE InputPoint;

        InputPoint.ssIdx     = LOCAL_currentFrame->frameDefinition.linearizerFrame.linearizer_subsystem_index;
        InputPoint.objIdx    = LOCAL_currentFrame->frameDefinition.linearizerFrame.inpoint_object_index;
        InputPoint.attribIdx = LOCAL_linearizerPoint;

        // Get the process value
        SIGNAL_TABLE_TYPE const *pSignal = FrameTableGetSignal(LOCAL_currentFrame->frameDefinition.linearizerFrame.ProcessSignal);
        ADJUST_DATA ProcessSignalValue;
        TUSIGN8     ProcessSignalType;
        if ((TUSIGN16)OK == AdjusterGetFloatValue(pSignal->value.ssIdx,        // TUSIGN16 subsysIdx
                                                  pSignal->value.objIdx,       // TUSIGN16 objIdx
                                                  pSignal->value.attribIdx,    // TUSIGN8 attribIdx
                                                  &ProcessSignalValue,         // ADJUST_DATA *pValue
                                                  &ProcessSignalType))         // TUSIGN8 *pType
        {
            // Get the input point - Only need the type
            ADJUST_DATA InputPointValue;
            TUSIGN8     InputPointType;
             if ((TUSIGN16)OK == AdjusterGetFloatValue(InputPoint.ssIdx,            // TUSIGN16 subsysIdx
                                                       InputPoint.objIdx,           // TUSIGN16 objIdx
                                                       InputPoint.attribIdx,        // TUSIGN8 attribIdx
                                                       &InputPointValue,            // ADJUST_DATA *pValue
                                                       &InputPointType))            // TUSIGN8 *pType
            {
                // Write the process value to the input point
                if ((TUSIGN16)OK == AdjusterWriteValueAndCheckLimits(InputPoint.ssIdx,            // TUSIGN16 subsysIdx,
                                                                     InputPoint.objIdx,           // TUSIGN16 objIdx,
                                                                     InputPoint.attribIdx,        // TUSIGN8 attribIdx,
                                                                     &ProcessSignalValue,         // const ADJUST_DATA *pValue,
                                                                     InputPointType))             // TUSIGN8 data_Type
                {
                    returnVal = eTRUE;
                }
            }
        }
    }
    return returnVal;
}

TBOOL FrameTable_SetLinearizerPointEnable(TBOOL enable)
{
    TBOOL returnVal = eFALSE;

    if (LOCAL_linearizerPointEnableDisable_Enabled)
    {
        ATTRIB_IDENTIFIER_TYPE PointEnable;

        PointEnable.ssIdx     = LOCAL_currentFrame->frameDefinition.linearizerFrame.linearizer_subsystem_index;
        PointEnable.objIdx    = LOCAL_currentFrame->frameDefinition.linearizerFrame.pointEnable_objectIndex;
        PointEnable.attribIdx = LOCAL_linearizerPoint;

        // Set the enable
        TUSIGN8 PointEnableValue = enable ? 1 : 0;

        //Write the enable
        if ((TUSIGN16)OK == AdjusterWriteAttribute(PointEnable.ssIdx,                  // TUSIGN16 subsysIdx
                                                   PointEnable.objIdx,                 // TUSIGN16 objIdx
                                                   PointEnable.attribIdx,              // TUSIGN8 attribIdx
                                                   (void FAST *)&PointEnableValue))    // void FAST *ptrValue)
        {
            returnVal = eTRUE;
        }
    }
    return returnVal;
}

TBOOL FrameTable_GetLinearizerPointEnable(TUSIGN8 PointEnable_ssIdx, TUSIGN8 PointEnable_objIdx, TUSIGN8 PointEnable_attribIdx)
{
    TBOOL returnVal = eFALSE;

    // Get the enable
    TUSIGN8 PointEnableValue;

    if ((TUSIGN16)OK == AdjusterGetAttribute(PointEnable_ssIdx,                  // TUSIGN16 subsysIdx
                                             PointEnable_objIdx,                 // TUSIGN16 objIdx
                                             PointEnable_attribIdx,              // TUSIGN8 attribIdx
                                             (void FAST *)&PointEnableValue))    // void FAST *ptrValue)
    {
        if (PointEnableValue)
        {
            returnVal = eTRUE;
        }
    }
    return returnVal;
}

void FrameTable_EnableLinearizerFrameFeatures(TBOOL ProcessValueDisplay, TBOOL InpointCapture, TBOOL InpointEdit, TBOOL OutpointEdit, TBOOL PointEnableDisable)
{
    LOCAL_linearizerProcessValueDisplay_Enabled = ProcessValueDisplay;
    LOCAL_linearizerInpointCapture_Enabled = InpointCapture;
    LOCAL_linearizerInpointEdit_Enabled = InpointEdit;
    LOCAL_linearizerOutpointEdit_Enabled = OutpointEdit;
    LOCAL_linearizerPointEnableDisable_Enabled = PointEnableDisable;
}

TBOOL FrameTable_isLinearizerProcessValueDisplayEnabled()
{
    return LOCAL_linearizerProcessValueDisplay_Enabled;
}
TBOOL FrameTable_isLinearizerInpointCapture_Enabled()
{
    return LOCAL_linearizerInpointCapture_Enabled;
}
TBOOL FrameTable_isLinearizerInpointEdit_Enabled()
{
    return LOCAL_linearizerInpointEdit_Enabled;
}
TBOOL FrameTable_isLinearizerOutpointEdit_Enabled()
{
    return LOCAL_linearizerOutpointEdit_Enabled;
}
TBOOL FrameTable_isLinearizerPointEnableDisable_Enabled()
{
    return LOCAL_linearizerPointEnableDisable_Enabled;
}
#endif

#ifdef HMI_SUPPORTS_MATRIX_FRAMES
MATRIX_CURSOR_POS FrameTable_GetMatrixCursor(void)
{
    return LOCAL_matrixCursor;
}

TBOOL FrameTable_NextMatrixCursor(void)
{
    TBOOL returnVal = eTRUE;

    switch (LOCAL_matrixCursor)
    {
    case MATRIX_CURSOR_EXIT:
        LOCAL_matrixCursor = MATRIX_CURSOR_COLUMN;
        break;

    case MATRIX_CURSOR_COLUMN:
        LOCAL_matrixCursor = MATRIX_CURSOR_ROW;
        break;

    case MATRIX_CURSOR_ROW:
        LOCAL_matrixCursor = MATRIX_CURSOR_ELEMENT;
        break;

    case MATRIX_CURSOR_ELEMENT:
        {
            TUSIGN16 MatrixSubsystem = (TUSIGN16)(LOCAL_currentFrame->frameDefinition.matrixFrame.matrix_subsystem_index);
            TUSIGN16 MatrixObject    = (TUSIGN16)LOCAL_currentFrame->frameDefinition.matrixFrame.matrix_object_index;
            const T_MATRIX *pMatrix  = (T_MATRIX*)(GetSubsystemPtr(MatrixSubsystem));
            TUSIGN8 MatrixNumber;

            if (((T_UNIT*)pMatrix)->Get((T_UNIT*)pMatrix, MatrixObject, 0, (void FAST *)&MatrixNumber) == (TUSIGN16)OK)
            {

                TUSIGN8 calcAvailable;
                if (pMatrix->GetMatrixData(MatrixNumber, HMI_MATRIX_CALCULATION, &calcAvailable) != eTRUE)
                {
                    calcAvailable = 0;
                }

                if (calcAvailable)
                {
                    TBOOL elementCalc;
                    if (pMatrix->GetIsElementCalculated(MatrixNumber, LOCAL_matrixRow, LOCAL_matrixColumn, &elementCalc) != eTRUE)
                    {
                        elementCalc = eFALSE;
                    }

                    if (elementCalc)
                    {
                        // element calculated - no option to make it calculated
                        LOCAL_matrixCursor = MATRIX_CURSOR_EXIT;
                    }
                    else
                    {
                        // element not calculated - option to make it calculated
                        LOCAL_matrixCursor = MATRIX_CURSOR_ELEMENT_RESET;
                    }
                }
                else
                {
                    LOCAL_matrixCursor = MATRIX_CURSOR_EXIT;
                }
            }
            else
            {
                LOCAL_matrixCursor = MATRIX_CURSOR_EXIT;
            }
        }
        break;

    case MATRIX_CURSOR_ELEMENT_RESET:
        LOCAL_matrixCursor = MATRIX_CURSOR_EXIT;
        break;

    case MATRIX_CURSOR_COLUMN_EDIT:
    case MATRIX_CURSOR_ROW_EDIT:
    case MATRIX_CURSOR_ELEMENT_EDIT:
        returnVal = eFALSE;
        break;

    default:
        LOCAL_matrixCursor = MATRIX_CURSOR_EXIT;
        break;
    }
    return returnVal;
}

TUSIGN8 FrameTable_GetMatrixColumn(void)
{
    return LOCAL_matrixColumn;
}

void FrameTable_NextMatrixElement(TBOOL up)
{
    TUSIGN16 MatrixSubsystem = (TUSIGN16)(LOCAL_currentFrame->frameDefinition.matrixFrame.matrix_subsystem_index);
    TUSIGN16 MatrixObject    = (TUSIGN16)LOCAL_currentFrame->frameDefinition.matrixFrame.matrix_object_index;
    const T_MATRIX *pMatrix  = (T_MATRIX*)(GetSubsystemPtr(MatrixSubsystem));
    TUSIGN8 MatrixNumber;

    TUSIGN16 retCode = ((T_UNIT*)pMatrix)->Get((T_UNIT*)pMatrix, MatrixObject, 0, (void FAST *)&MatrixNumber);

    if (retCode == (TUSIGN16)OK)
    {
        TUSIGN8 minCol, maxCol, minRow, maxRow;

        if (pMatrix->GetMatrixData(MatrixNumber, HMI_MATRIX_MIN_COLUMN, &minCol) != eTRUE)  {minCol = 0;}
        if (pMatrix->GetMatrixData(MatrixNumber, HMI_MATRIX_MAX_COLUMN, &maxCol) != eTRUE)  {maxCol = 0;}
        if (pMatrix->GetMatrixData(MatrixNumber, HMI_MATRIX_MIN_ROW,    &minRow) != eTRUE)  {minRow = 0;}
        if (pMatrix->GetMatrixData(MatrixNumber, HMI_MATRIX_MAX_ROW,    &maxRow) != eTRUE)  {maxRow = 0;}

        if (LOCAL_matrixCursor == MATRIX_CURSOR_COLUMN)
        {
            if (( up) && (LOCAL_matrixColumn < maxCol))  {LOCAL_matrixColumn++;}
            if ((!up) && (LOCAL_matrixColumn > minCol))  {LOCAL_matrixColumn--;}
        }

        if (LOCAL_matrixCursor == MATRIX_CURSOR_ROW)
        {
            if (( up) && (LOCAL_matrixRow    < maxRow))  {LOCAL_matrixRow++;}
            if ((!up) && (LOCAL_matrixRow    > minRow))  {LOCAL_matrixRow--;}
        }

        if ((LOCAL_matrixColumn > maxCol) || (LOCAL_matrixColumn < minCol)) {LOCAL_matrixColumn = minCol;}
        if ((LOCAL_matrixRow    > maxRow) || (LOCAL_matrixRow    < minRow)) {LOCAL_matrixRow    = minRow;}
    }
}

TUSIGN8 FrameTable_GetMatrixRow(void)
{
    return LOCAL_matrixRow;
}

TBOOL FrameTable_ResetMatrixElement(void)
{
    TBOOL ReturnVal = eFALSE;

    if (LOCAL_matrixCursor == MATRIX_CURSOR_ELEMENT_RESET)
    {
        TUSIGN16 MatrixSubsystem = (TUSIGN16)(LOCAL_currentFrame->frameDefinition.matrixFrame.matrix_subsystem_index);
        TUSIGN16 MatrixObject    = (TUSIGN16)LOCAL_currentFrame->frameDefinition.matrixFrame.matrix_object_index;
        const T_MATRIX *pMatrix  = (T_MATRIX*)(GetSubsystemPtr(MatrixSubsystem));
        TUSIGN8 MatrixNumber;

        if (((T_UNIT*)pMatrix)->Get((T_UNIT*)pMatrix, MatrixObject, 0, (void FAST *)&MatrixNumber) == (TUSIGN16)OK)
        {
            ReturnVal = pMatrix->ResetElement(MatrixNumber, LOCAL_matrixColumn, LOCAL_matrixRow);
        }
    }
    return ReturnVal;
}

TBOOL FrameTable_MatrixEdit(TBOOL enable)
{
    TBOOL returnVal = eFALSE;

    if (enable)
    {

        if ((LOCAL_matrixCursor == MATRIX_CURSOR_COLUMN)
         || (LOCAL_matrixCursor == MATRIX_CURSOR_ROW)
         || (LOCAL_matrixCursor == MATRIX_CURSOR_ELEMENT))
        {
            TUSIGN16 MatrixSubsystem = (TUSIGN16)(LOCAL_currentFrame->frameDefinition.matrixFrame.matrix_subsystem_index);
            TUSIGN16 MatrixObject    = (TUSIGN16)LOCAL_currentFrame->frameDefinition.matrixFrame.matrix_object_index;
            const T_MATRIX *pMatrix  = (T_MATRIX*)(GetSubsystemPtr(MatrixSubsystem));
            TUSIGN8 MatrixNumber;

            if (((T_UNIT*)pMatrix)->Get((T_UNIT*)pMatrix, MatrixObject, 0, (void FAST *)&MatrixNumber) == (TUSIGN16)OK)
            {
                T_SUBSYSTEM_IDX DataSS;
                TUSIGN16        DataObj;
                TINT16          DataAtt;

                TBOOL           DataValid;

                switch (LOCAL_matrixCursor)
                {
                case MATRIX_CURSOR_COLUMN:  DataValid = pMatrix->GetColumnObjIndeces(MatrixNumber, LOCAL_matrixColumn, &DataSS, &DataObj, &DataAtt);                    break;
                case MATRIX_CURSOR_ROW:     DataValid = pMatrix->GetRowObjIndeces(MatrixNumber, LOCAL_matrixRow, &DataSS, &DataObj, &DataAtt);                          break;
                case MATRIX_CURSOR_ELEMENT: DataValid = pMatrix->GetElementObjIndeces(MatrixNumber, LOCAL_matrixColumn, LOCAL_matrixRow, &DataSS, &DataObj, &DataAtt);  break;
                default:                    DataValid = eFALSE;                                                                                                         break;
                }

                if (DataValid)
                {
                    ATTRIB_IDENTIFIER_TYPE valueID;

                    valueID.ssIdx = DataSS;
                    valueID.objIdx = DataObj;
                    valueID.attribIdx = DataAtt;

                   if (WriteProtect_HMICanAccess(valueID, (TUSIGN8)0))
                   {
                        if (Setup_Matrix_NumericFrame((MATRIX_CURSOR_POS)(LOCAL_matrixCursor + 1)))
                        {
                            LOCAL_matrixCursor ++;

                            LOCAL_editEnabled = 1;
                            LOCAL_cursorPosition = 0;
                            LOCAL_cursorPositionLimit = 6 + 1;


                            AdjusterPrepareNewVariable(0);
                            AdjusterInitialiseNewVariable((void *)&LOCAL_inherentNumericFrame);

                            returnVal = eTRUE;
                        }
                   }
                }
            }
        }
    }
    else
    {
        if ((LOCAL_matrixCursor == MATRIX_CURSOR_COLUMN_EDIT)
         || (LOCAL_matrixCursor == MATRIX_CURSOR_ROW_EDIT)
         || (LOCAL_matrixCursor == MATRIX_CURSOR_ELEMENT_EDIT))
        {
            LOCAL_matrixCursor --;
            returnVal = eTRUE;
        }
    }
    return returnVal;
}

TBOOL Setup_Matrix_NumericFrame(MATRIX_CURSOR_POS cursorPos)
{
    TBOOL SuccessfulSetup = eFALSE;

    TUSIGN16 MatrixSubsystem = (TUSIGN16)(LOCAL_currentFrame->frameDefinition.matrixFrame.matrix_subsystem_index);
    TUSIGN16 MatrixObject    = (TUSIGN16)LOCAL_currentFrame->frameDefinition.matrixFrame.matrix_object_index;
    const T_MATRIX *pMatrix  = (T_MATRIX*)(GetSubsystemPtr(MatrixSubsystem));
    TUSIGN8 MatrixNumber;

    if (((T_UNIT*)pMatrix)->Get((T_UNIT*)pMatrix, MatrixObject, 0, (void FAST *)&MatrixNumber) == (TUSIGN16)OK)
    {
        TUSIGN16 DataSS;
        TUSIGN16 DataObj;
        TINT16   DataAtt;

        TBOOL dataValid;
        TUSIGN8 temp_dp;

        switch(cursorPos)
        {
        case MATRIX_CURSOR_COLUMN_EDIT:
            temp_dp = LOCAL_currentFrame->frameDefinition.matrixFrame.dpPosn_Col;
            dataValid = pMatrix->GetColumnObjIndeces(MatrixNumber, LOCAL_matrixColumn, &DataSS, &DataObj, &DataAtt);
            break;

        case MATRIX_CURSOR_ROW_EDIT:
            temp_dp = LOCAL_currentFrame->frameDefinition.matrixFrame.dpPosn_Row;
            dataValid = pMatrix->GetRowObjIndeces(MatrixNumber, LOCAL_matrixRow, &DataSS, &DataObj, &DataAtt);
            break;

        case MATRIX_CURSOR_ELEMENT_EDIT:
            temp_dp = LOCAL_currentFrame->frameDefinition.matrixFrame.dpPosn_Elm;
            dataValid = pMatrix->GetElementObjIndeces(MatrixNumber, LOCAL_matrixColumn, LOCAL_matrixRow, &DataSS, &DataObj, &DataAtt);
            break;

        default:
            dataValid = eFALSE;
            break;
        }

        if ((dataValid)
         && (DataSS  <= 255)
         && (DataObj <= 255)
         && (DataAtt >= 0)
         && (DataAtt <= 254))
        {
            LOCAL_inherentNumericFrame.frameType                                                            = FRAME_TYPE_NUMERICAL_PARAM;
            #ifdef HMI_USES_SPECIAL_OP_CODES
            LOCAL_inherentNumericFrame.specialOpCode[0]                                                     = IDF_SPECIAL_NONE;
            LOCAL_inherentNumericFrame.specialOpCode[1]                                                     = IDF_SPECIAL_NONE;
            LOCAL_inherentNumericFrame.specialOpCode[2]                                                     = IDF_SPECIAL_NONE;
            #endif

            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.pFaultFrame                      = 0;

            // Set up Title Bar & Title fixed text (blank) - These parameters are not used
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.titleBar_attribidx               = IDS_BLANK;
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.title_attribidx                  = IDS_BLANK;

            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.value.ssIdx                      = (TUSIGN8)DataSS;
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.value.objIdx                     = (TUSIGN8)DataObj;
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.value.attribIdx                  = (TUSIGN8)DataAtt;

            // Set up Engineering units as fixed text (blank) - These parameters are not used
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.engUnits.ssIdx                   = 0;            //MatrixSubsystem
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.engUnits.objIdx                  = IDS_BLANK;    //MatrixObject
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.engUnits.attribIdx               = 0;            //0

            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.engUnitsType                     = FIXED_TEXT_UNITS;

            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.attributes.maxCharacters         = 6;
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.attributes.characterSet_dpPosn   = temp_dp;

            #ifdef HMI_SUPPORTS_EASYSETUP
            LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.easySetupFlag                    = 0;
            #endif

            SuccessfulSetup = eTRUE;
        }
    }
    return SuccessfulSetup;
}

void FrameTable_ModifyDataForWriteProtection(ATTRIB_IDENTIFIER_TYPE* pData)
{
    if ((LOCAL_currentFrame->frameType == FRAME_TYPE_MATRIX_T_C_D)
     || (LOCAL_currentFrame->frameType == FRAME_TYPE_MATRIX_X_Y_XY))
    {
        pData->ssIdx     = (TUSIGN8)LOCAL_currentFrame->frameDefinition.matrixFrame.matrix_subsystem_index;
        pData->objIdx    = (TUSIGN8)LOCAL_currentFrame->frameDefinition.matrixFrame.matrix_object_index;
        pData->attribIdx = 0;
    }
}

void Initialise_MatrixData(FRAME_FORMAT_TYPE const *pMatrixFrame)
{
    TUSIGN16 MatrixSubsystem = (TUSIGN16)pMatrixFrame->frameDefinition.matrixFrame.matrix_subsystem_index;
    TUSIGN16 MatrixObject    = (TUSIGN16)pMatrixFrame->frameDefinition.matrixFrame.matrix_object_index;
    const T_MATRIX *pMatrix  = (T_MATRIX*)(GetSubsystemPtr(MatrixSubsystem));
    TUSIGN8 MatrixNumber;

    if (((T_UNIT*)pMatrix)->Get((T_UNIT*)pMatrix, MatrixObject, 0, (void FAST *)&MatrixNumber) == (TUSIGN16)OK)
    {
        if (pMatrix->GetMatrixData(MatrixNumber, HMI_MATRIX_MIN_COLUMN, &LOCAL_matrixColumn) != eTRUE)
        {
            LOCAL_matrixColumn = 0;
        }

        if (pMatrix->GetMatrixData(MatrixNumber, HMI_MATRIX_MIN_ROW, &LOCAL_matrixRow) != eTRUE)
        {
            LOCAL_matrixRow = 0;
        }
    }
    LOCAL_matrixCursor = MATRIX_CURSOR_EXIT;
}
#endif


#ifdef HMI_SUPPORTS_WAVEFORM_FRAMES
TUSIGN8 FrameTable_GetWaveformPRVSignal(TUSIGN8 waveformNumber)
{
    return (TUSIGN8)(waveformPRV[waveformNumber][waveformPRVindex[waveformNumber]] - 1);
}

TUSIGN8 FrameTable_GetWaveformCRVSignal(TUSIGN8 waveformNumber)
{
    return (TUSIGN8)(waveformCRV[waveformNumber][waveformCRVindex[waveformNumber]] - 1);
}

void FrameTable_NextWaveformPRVSignal(TUSIGN8 waveformNumber)
{
    do
    {
        waveformPRVindex[waveformNumber] = waveformPRVindex[waveformNumber] >= 9 ? 0 : waveformPRVindex[waveformNumber] + 1;
    }
    while (waveformPRV[waveformNumber][waveformPRVindex[waveformNumber]] == 0);
}

void FrameTable_PrevWaveformPRVSignal(TUSIGN8 waveformNumber)
{
    do
    {
        waveformPRVindex[waveformNumber] = waveformPRVindex[waveformNumber] == 0 ? 9 : waveformPRVindex[waveformNumber] -1;
    }
    while (waveformPRV[waveformNumber][waveformPRVindex[waveformNumber]] == 0);
}

void FrameTable_NextWaveformCRVSignal(TUSIGN8 waveformNumber)
{
    do
    {
        waveformCRVindex[waveformNumber] = waveformCRVindex[waveformNumber] >= 9 ? 0 : waveformCRVindex[waveformNumber] + 1;
    }
    while (waveformCRV[waveformNumber][waveformCRVindex[waveformNumber]] == 0);
}

void FrameTable_PrevWaveformCRVSignal(TUSIGN8 waveformNumber)
{
    do
    {
        waveformCRVindex[waveformNumber] = waveformCRVindex[waveformNumber] == 0 ? 9 : waveformCRVindex[waveformNumber] -1;
    }
    while (waveformCRV[waveformNumber][waveformCRVindex[waveformNumber]] == 0);
}

WAVEFORM_CURSOR_POS FrameTable_GetWaveformCursor(TUSIGN8 waveformNumber)
{
    return waveformCursor[waveformNumber];
}

void FrameTable_NextWaveformCursor(TUSIGN8 waveformNumber)
{
    switch (waveformCursor[waveformNumber])
    {
    case WAVEFORM_CURSOR_PRC_REL_VAL:   waveformCursor[waveformNumber] = WAVEFORM_CURSOR_CFG_REL_VAL; break;
    case WAVEFORM_CURSOR_CFG_REL_VAL:   waveformCursor[waveformNumber] = WAVEFORM_CURSOR_H_WIDTH;     break;
    case WAVEFORM_CURSOR_H_WIDTH:       waveformCursor[waveformNumber] = WAVEFORM_CURSOR_H_OFFSET;    break;
    case WAVEFORM_CURSOR_H_OFFSET:      waveformCursor[waveformNumber] = WAVEFORM_CURSOR_PRC_REL_VAL; break;
    default:                            waveformCursor[waveformNumber] = WAVEFORM_CURSOR_PRC_REL_VAL; break;
    }
    waveformCursorChange[waveformNumber] = eTRUE;
}

void FrameTable_WaveformCRV_Edit(TUSIGN8 waveformNumber, TBOOL enable)
{
    if (enable)
    {
        if (waveformCursor[waveformNumber] != WAVEFORM_CURSOR_CFG_REL_VAL_EDIT)
        {
            waveformCursor[waveformNumber] = WAVEFORM_CURSOR_CFG_REL_VAL_EDIT;
            waveformEditStateChange[waveformNumber] = eTRUE;

            LOCAL_editEnabled = 1;
            LOCAL_cursorPosition = 0;
            LOCAL_cursorPositionLimit = CRV_EDIT_MAX_CHARS + 1;

            FrameTable_SetupCRV_NumericFrame(FrameTable_GetWaveformCRVSignal(waveformNumber));

            AdjusterPrepareNewVariable(0);
            AdjusterInitialiseNewVariable((void *)&LOCAL_inherentNumericFrame);
        }
    }
    else
    {
        if (waveformCursor[waveformNumber] == WAVEFORM_CURSOR_CFG_REL_VAL_EDIT)
        {


            waveformCursor[waveformNumber] = WAVEFORM_CURSOR_CFG_REL_VAL;
            waveformEditStateChange[waveformNumber] = eTRUE;
        }
    }
}

TBOOL FrameTable_IsWaveformCursorChanged(TUSIGN8 waveformNumber)
{
    return waveformCursorChange[waveformNumber];
}

void FrameTable_AcknowledgeWaveformCursorChange(TUSIGN8 waveformNumber)
{
    waveformCursorChange[waveformNumber] = eFALSE;
}

TBOOL FrameTable_IsWaveformEditStateChanged(TUSIGN8 waveformNumber)
{
    return waveformEditStateChange[waveformNumber];
}

void FrameTable_AcknowledgeWaveformEditStateChange(TUSIGN8 waveformNumber)
{
    waveformEditStateChange[waveformNumber] = eFALSE;
}

void FrameTable_SetupCRV_NumericFrame(TUSIGN8 Signal)
{
    const SIGNAL_TABLE_TYPE *pSignal = FrameTableGetSignal(Signal);

    LOCAL_inherentNumericFrame.frameType                                                          = FRAME_TYPE_NUMERICAL_PARAM;
    #ifdef HMI_USES_SPECIAL_OP_CODES
    LOCAL_inherentNumericFrame.specialOpCode[0]                                                   = IDF_SPECIAL_NONE;
    LOCAL_inherentNumericFrame.specialOpCode[1]                                                   = IDF_SPECIAL_NONE;
    LOCAL_inherentNumericFrame.specialOpCode[2]                                                   = IDF_SPECIAL_NONE;
    #endif

    LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.titleBar_attribidx             = IDS_BLANK;
    LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.title_attribidx                = pSignal->long_identifier;

    LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.value                          = pSignal->value;
    LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.engUnits                       = pSignal->engUnits;

    LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.engUnitsType                   = pSignal->engUnitsType;
    LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.attributes.maxCharacters       = CRV_EDIT_MAX_CHARS;
    LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.attributes.characterSet_dpPosn = pSignal->dpPosn;

    #ifdef HMI_SUPPORTS_EASYSETUP
    LOCAL_inherentNumericFrame.frameDefinition.numericalParamFrame.easySetupFlag                  = 0;
    #endif
}
#endif // end of #ifdef HMI_SUPPORTS_WAVEFORM_FRAMES

/*!
 \brief         Get the currently active frame
 \author        Roger Arnold
 \param
 \return        pointer to the definition of the currently active frame
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
FRAME_FORMAT_TYPE const *FrameTableGetCurrentFrame(void)
{
        return LOCAL_currentFrame;
}

#ifdef HMI_SUPPORTS_SERVICEPORT
FRAME_FORMAT_TYPE const *FrameTableGetCurrentFrame_LOCAL(void)
{
        return FrameTableLocal_1.currentFrame;
}

FRAME_FORMAT_TYPE const *FrameTableGetCurrentFrame_REMOTE(void)
{
        return FrameTableLocal_2.currentFrame;
}
#endif

/*!
 \brief         Gets the address of the first/last configuration header frame
 \author        Roger Arnold
 \param         first_last - 0, Gets the address of the first configuration header frame
                                     1, Gets the address of the last configuration header frame
 \return        address of the selected configuration header frame
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
FRAME_FORMAT_TYPE const *FrameTableGetConfigHeaderAddress(TUSIGN8 first_last)
{
FRAME_FORMAT_TYPE const* returnVal;

#if defined (HMI_MODULE_TEST) && defined(HMI_MODULE_TEST_FRAMEMOVER)

    if (first_last == 0)
    {
        returnVal =  firstConfigHeader;
    }
    else
    {
        returnVal =  lastConfigHeader;
    }
#else

    if (first_last == 0)
    {
        returnVal = FIRSTCONFIGHEADER;
    }
    else
    {
        returnVal = LASTCONFIGHEADER;
    }
#endif
    return returnVal;
}

/*!
 \brief         Gets the address of the first operator frame
 \author        Roger Arnold
 \param         none
 \return        address of the first operator frame
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
FRAME_FORMAT_TYPE const *FrameTableGetFirstOpPageAddress(void)
{
    return STARTINGFRAME;
}

/*!
 \brief         Gets the address of the operator menu
 \author        Roger Arnold
 \param         none
 \return        address of the operator menu
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
FRAME_FORMAT_TYPE const *FrameTableGetOperatorMenuAddress(void)
{
    return OPERATORMENUFRAME;
}

/*!
 \brief         Gets the address of the signals view menu
 \author        Roger Arnold
 \param         none
 \return        address of the operator menu
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
FRAME_FORMAT_TYPE const *FrameTableGetSignalsViewAddress(void)
{
    return SIGNALSVIEWFRAME;
}

#ifdef HMI_SUPPORTS_SECURITY_ACCESS
/*!
 \brief         Gets the address of the ARM Level selection menu
 \author        Roger Arnold
 \param         none
 \return        address of the operator menu
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
FRAME_FORMAT_TYPE const *FrameTableGetARMSelectionAddress(void)
{
    return ARMLEVELSELECTION;
}

/*!
 \brief         Gets the address of the ARM Password Entry Frame
 \author        Roger Arnold
 \param         none
 \return        address of the operator menu
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
FRAME_FORMAT_TYPE const *FrameTableGetARMPasswordEntryAddress(void)
{
    return ARMPASSWORDENTRY;
}

/*!
 \brief         Sets the requested ARM Level
 \author        Roger Arnold
 \param         required ARM Level
 \return        none
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
void FrameTableSetRequestedARMLevel(TUSIGN8 RequestedLevel)
{
    LOCAL_RequestedARMLevel = RequestedLevel;
}

/*!
 \brief         Returns the requested ARM Level
 \author        Roger Arnold
 \param         none
 \return        requested ARM Level
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
TUSIGN8 FrameTableGetRequestedARMLevel(void)
{
    return LOCAL_RequestedARMLevel;
}

#endif

#ifdef HMI_USES_COMMONDIAGNOSTICS
/*!
 \brief         Gets the address of the diagnostics view menu
 \author        Roger Arnold
 \param         none
 \return        address of the operator menu
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
FRAME_FORMAT_TYPE const *FrameTableGetDiagnosticsViewAddress(void)
{
    return DIAGVIEWFRAME;
}

/*!
 \brief         Gets the address of the diagnostics icon
 \author        Roger Arnold
 \param         classification 0 - CLASSIFICATION_NONE
                               1 - CLASSIFICATION_CHECKFUNCTION
                               2 - CLASSIFICATION_OFFSPEC
                               3 - CLASSIFICATION_MAINTENANCEREQD
                               4 - CLASSIFICATION_FAILURE
                               5 = CLASSIFICATION_INFORMATIONONLY

 \return        address of the icon
 \test          No details available
*/
// No restriction on the optimization of this function
TUSIGN8 const *FrameTableGetDiagnosticIconAddress(TUSIGN8 classification, TUSIGN8 iconLine)
{
    if (iconLine > 1)
    {
        iconLine = 0;
        classification = 0;
    }
    if (classification > CLASSIFICATION_MAX)
    {
        classification = 0;

        #ifdef EDP300_SPECIAL_FEATURES_HMI
        classification = CLASSIFICATION_INFORMATIONONLY;
        #endif
    }

    return DiagnosticIconTable[classification][iconLine];
}

/*!
 \brief         Gets the string ID for the description of the selected diagnostics condition
 \author        Roger Arnold
 \param         TUSIGN8 condition - the diagnostics condition
 \return        STR_REF - string ID for the description of the selected diagnostics condition
 \test          No details available
*/
// No restriction on the optimization of this function
#ifdef COMMON_TOP_WORKS_NEW_FEATURES    // DIAGNOSTIC_SPLIT_DESC_AND_RECOVERY

DIAGNOSTICS_TABLE_ENTRY_TYPE FrameTableGetDiagnosticTableEntry(TUSIGN8 condition)
{
    TUSIGN8 i = 0;

    if(servicePort.ServPortGetActivationStatusSRV() == SERVICEPORT_HMI_STATUS)
    {    
#ifdef SUPPORT_OLD_HMI
        while ((DiagnosticConditionTable[i].condition != condition) && (DiagnosticConditionTable[i].condition != 0xFF))
        {
            i ++;
        }
        return DiagnosticConditionTable[i];
#endif
    }
    else if(servicePort.ServPortGetActivationStatusSRV() == SERVICEPORT_SHMI_STATUS)
    {
#ifdef SUPPORT_SHMI
        while ((DiagnosticConditionTable_s[i].condition != condition) && (DiagnosticConditionTable_s[i].condition != 0xFF))
        {
            i ++;
        }
        return DiagnosticConditionTable_s[i];
#endif
    }else
    {
#ifdef SUPPORT_OLD_HMI
        while ((DiagnosticConditionTable[i].condition != condition) && (DiagnosticConditionTable[i].condition != 0xFF))
        {
            i ++;
        }
        return DiagnosticConditionTable[i];
#endif      
    }
    
}

#else

STR_REF FrameTableGetDiagnosticDescriptionStringID(TUSIGN8 condition)
{
    TUSIGN8 i = 0;
    if(servicePort.ServPortGetActivationStatusSRV() == SERVICEPORT_HMI_STATUS)  
    {
#ifdef SUPPORT_OLD_HMI
        while ((DiagnosticConditionTable[i].condition != condition) && (DiagnosticConditionTable[i].condition != 0xFF))
        {
            i ++;
        }
        return DiagnosticConditionTable[i].stringID;
#endif
    }
    else if(servicePort.ServPortGetActivationStatusSRV() == SERVICEPORT_SHMI_STATUS)
    {
#ifdef SUPPORT_SHMI
        while ((DiagnosticConditionTable_s[i].condition != condition) && (DiagnosticConditionTable_s[i].condition != 0xFF))
        {
            i ++;
        }
        return DiagnosticConditionTable_s[i].stringID;

#endif
    }

    
}

#endif




/*!
 \brief         Gets the string ID for the selected diagnostics Category
 \author        Roger Arnold
 \param         TUSIGN8 Category - the diagnostics Category
 \return        STR_REF - string ID for the selected diagnostics Category
 \test          No details available
*/
// No restriction on the optimization of this function
STR_REF FrameTableGetNAMURCategoryString(TUSIGN8 Category)
{
    STR_REF returnVal;
    switch(Category)
    {
    case CATEGORY_CALIBRATION:      returnVal = IDS_CALIBRATION;            break;
    case CATEGORY_INFORMATION:      returnVal = IDS_INFORMATION;            break;
    case CATEGORY_POWERSUPPLY:      returnVal = IDS_POWERSUPPLY;            break;
    case CATEGORY_PROCESS:          returnVal = IDS_PROCESS;                break;
    case CATEGORY_ACTUATOR:         returnVal = IDS_ACTUATOR;               break;
    case CATEGORY_HARDWARE:         returnVal = IDS_HARDWARE;               break;
    case CATEGORY_ELECTRONICS:      returnVal = IDS_ELECTRONICS;            break;
    case CATEGORY_SENSOR:           returnVal = IDS_SENSOR;                 break;
    case CATEGORY_INSTALLATION:     returnVal = IDS_INSTALLATION;           break;
    case CATEGORY_OPERATION:        returnVal = IDS_OPERATION;              break;
    case CATEGORY_CONFIGURATION:    returnVal = IDS_CONFIGURATION;          break;

    case CATEGORY_SENSOR_1:         returnVal = IDS_SENSOR_1;               break;
    case CATEGORY_SENSOR_2:         returnVal = IDS_SENSOR_2;               break;
    case CATEGORY_SENSOR_3:         returnVal = IDS_SENSOR_3;               break;
    case CATEGORY_SENSOR_4:         returnVal = IDS_SENSOR_4;               break;
    case CATEGORY_SENSOR_5:         returnVal = IDS_SENSOR_5;               break;
    case CATEGORY_SENSOR_6:         returnVal = IDS_SENSOR_6;               break;
    case CATEGORY_TRANSMITTER:      returnVal = IDS_TRANSMITTER;            break;

    default:                        returnVal = IDS_UNSPECIFIED_CATEGORY;   break;
    }
    return returnVal;
}

#endif

/*!
 \brief         Changes the currently active frame
 \author        Roger Arnold
 \param         pointer to the definition of the new active frame
 \return        1 on success, 0 on any error.
 \test          No details available
*/
// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TUSIGN8 FrameTableSetCurrentFrame(FRAME_FORMAT_TYPE const *newFrame, TUSIGN8 cursor, TUSIGN16 extraSpecialOp)
{
    TUSIGN8 returnVal;
    TUSIGN16 cursorL,cursorH;
    TUSIGN8 loop = 0;

    if (LOCAL_currentFrame != newFrame)
    {
        #ifdef HMI_USES_SPECIAL_OP_CODES

            if (LOCAL_currentFrame)
            {
                SpecialOperationExecute((TUSIGN16)(LOCAL_currentFrame->specialOpCode[2]));
            }

            #ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
            (void)FrameTableSetOutputHoldSettings(eFALSE, 0, 0, 0);
            #endif

            #ifdef HMI_SUPPORTS_SECONDARY_IDENTIFIER
            FrameTableSetSecondaryIdentifier(eFALSE, (unsigned char *)NULL);
            #endif

            #ifdef HMI_SUPPORTS_MANUAL_ADJUST_MODIFIER
            FrameTableSetManualAdjustModifier(0);
            #endif

            #ifdef MANUAL_ADJUST_ACCELERATOR
            FrameTableSetSpecialManualAdjust(4, 0, 0);
            #endif

            #ifdef HMI_SUPPORTS_MANUAL_VALVE_CAL
            FrameTableDeactivateManualValveCal();
            #endif

            #ifdef HMI_SUPPORTS_CONFIG_CHANGE_COUNTER
            FrameTableDeactivateConfigChangeCounter();
            #endif

            #ifdef HMI_SUPPORTS_AUTO_ADJUST
            FrameTableSetAutoAdjustAbortSettings(eFALSE, 0, 0, 0);
            #endif

            #ifdef HMI_SUPPORTS_AUTO_CALIBRATION
            FrameTableAllowNavigationFromAutoCal(eFALSE);
            FrameTableRenameAutocal(eFALSE);
            FrameTableRemoveSettling(eFALSE);
            #endif

            #ifdef HMI_SUPPORTS_MANUAL_CALIBRATION
            FrameTableEnableSampleCollection(eFALSE);
            #endif

            FrameTableRestrictNumericCharacterSet(eTRUE, eTRUE, 9);

            LOCAL_SpecialOpDenyEdit = eFALSE;
        #endif

        #ifdef HMI_SUPPORTS_LINEARIZER_FRAMES
        FrameTable_EnableLinearizerFrameFeatures(eTRUE, eTRUE, eTRUE, eTRUE, eTRUE);
        #endif

        #ifdef HMI_SUPPORTS_TIME_DATE_PARAM_FRAMES
        FrameTableSetTimeDurationLimit(200);
        #endif

        #ifdef HMI_SUPPORTS_GRAPH_VIEW
        (void)TrendViewStopSampling();
        #endif

        #ifdef HMI_SUPPORTS_GRAPH_PARAM_FRAMES
        (void)TrendViewStopArrayCalculation();
        #endif

        if (extraSpecialOp != IDF_SPECIAL_NONE)
        {
            SpecialOperationExecute(extraSpecialOp);

            #if defined(IDF_SPECIAL_INH_RETURN_TO_OPERATOR_PAGE) && defined(IDF_SPECIAL_INH_EXIT_CONFIG)
            if (extraSpecialOp == IDF_SPECIAL_INH_EXIT_CONFIG)
            {
                SpecialOperationExecute(IDF_SPECIAL_INH_RETURN_TO_OPERATOR_PAGE);
            }
            #endif
        }

        #ifdef HMI_USES_SPECIAL_OP_CODES
            SpecialOperationExecute((TUSIGN16)(newFrame->specialOpCode[0]));
        #endif
    }

    switch (newFrame->frameType)
    {
    case FRAME_TYPE_OPERATOR:
        // prepare operator frame variables
        returnVal = 1;
        LOCAL_operatorFrameActive = eTRUE;
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        EDP300ModeRequestAccessToMode(eFALSE);
        #endif
        break;

    case FRAME_TYPE_CONFIG_HEADER:
        // prepare config header frame variables
        #ifdef HMI_SUPPORTS_EASYSETUP
        if (newFrame->frameDefinition.configHeaderFrame.easySetupFlag != 0)
        {
            FRAME_FORMAT_TYPE const *pEasySetupItem = newFrame->frameDefinition.configHeaderFrame.pNextFrame;
            TUSIGN8 EasySetupItem_EasySetupFlag, nStages;
            LOCAL_easySetup_lastStage = 0;
            LOCAL_easySetup_actualStage = 0;

            nStages = 0;

            do
            {
                EasySetupItem_EasySetupFlag = 0;
                if (pEasySetupItem)
                {
                    switch (pEasySetupItem->frameType)
                    {
                    #ifdef HMI_SUPPORTS_GRAPH_PARAM_FRAMES
                    case FRAME_TYPE_GRAPH_PARAM_FRAME_1_NO_EDIT:
                    case FRAME_TYPE_GRAPH_PARAM_FRAME_2_NO_EDIT:
                        EasySetupItem_EasySetupFlag = pEasySetupItem->frameDefinition.graphParamFrame.easySetupFlag;
                        break;
                    #endif

                    case FRAME_TYPE_NUMERICAL_PARAM:
                    case FRAME_TYPE_NUMERICAL_PARAM_NO_EDIT:
                    case FRAME_TYPE_INTEGER_PARAM:
                    case FRAME_TYPE_INTEGER_PARAM_NO_EDIT:
                        EasySetupItem_EasySetupFlag = pEasySetupItem->frameDefinition.numericalParamFrame.easySetupFlag;
                        break;

                    case FRAME_TYPE_ENUMERATED_PARAM:
                    case FRAME_TYPE_ENUMERATED_PARAM_NO_EDIT:
                    case FRAME_TYPE_ENUMERATED_PARAM_OVERRIDE_WP:
                        EasySetupItem_EasySetupFlag = pEasySetupItem->frameDefinition.enumParamFrame.easySetupFlag;
                        break;

                    case FRAME_TYPE_MANUAL_ADJUST:
                    case FRAME_TYPE_AUTO_ADJUST:
                    case FRAME_TYPE_AUTO_ADJUST_WITH_TIMER_AND_RESULT:
                        EasySetupItem_EasySetupFlag = pEasySetupItem->frameDefinition.adjParamFrame.easySetupFlag;
                        break;

                    case FRAME_TYPE_STRING_PARAM:
                    case FRAME_TYPE_STRING_PARAM_NO_EDIT:
                    case FRAME_TYPE_STRING_PARAM_PACKED:
                    case FRAME_TYPE_STRING_PARAM_PACKED_NO_EDIT:
                        EasySetupItem_EasySetupFlag = pEasySetupItem->frameDefinition.stringParamFrame.easySetupFlag;
                        break;

                    case FRAME_TYPE_TIME_AND_DATE_PARAM:
                    case FRAME_TYPE_TIME_AND_DATE_PARAM_NO_EDIT:
                    case FRAME_TYPE_IP_ADDRESS:
                    case FRAME_TYPE_IP_ADDRESS_NO_EDIT:
                        EasySetupItem_EasySetupFlag = pEasySetupItem->frameDefinition.timeDateFrame.easySetupFlag;
                        break;

                    #ifdef HMI_SUPPORTS_BIT_ENUM_PARAM_FRAMES
                    case FRAME_TYPE_BIT_ENUMERATED_PARAM:
                    case FRAME_TYPE_BIT_ENUMERATED_PARAM_NO_EDIT:
                        EasySetupItem_EasySetupFlag = pEasySetupItem->frameDefinition.bitEnumParamFrame.easySetupFlag;
                        break;
                    #endif

                     default:
                        asm("nop");
                        break;
                    }

                    if (EasySetupItem_EasySetupFlag)
                    {
                        nStages ++;
                        // No alternative but to use pointer arithmetic
                        #pragma diag_suppress=Pm088
                        pEasySetupItem ++;
                        #pragma diag_default=Pm088
                    }
                }
            } while (EasySetupItem_EasySetupFlag);

            if (nStages)
            {
                LOCAL_easySetup_lastStage = nStages - 1;
            }
        }
        #endif

        returnVal = 1;
        LOCAL_operatorFrameActive = eFALSE;
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        EDP300ModeRequestAccessToMode(eTRUE);
        #endif
        break;

    case FRAME_TYPE_MENU:

        if ((newFrame->frameDefinition.menuFrame.specialMenuFlag == 1)  // 1 = Operator Menu
         || (newFrame->frameDefinition.menuFrame.specialMenuFlag == 2)  // 2 = Signals View
         || (newFrame->frameDefinition.menuFrame.specialMenuFlag == 3)  // 3 = Diagnostics View
         || (newFrame->frameDefinition.menuFrame.specialMenuFlag == 7)) // 7 = EDP300 Mode Frame
        {
            LOCAL_operatorFrameActive = eTRUE;
            #ifdef EDP300_SPECIAL_FEATURES_HMI
            EDP300ModeRequestAccessToMode(eFALSE);
            #endif
        }
        else
        {
            LOCAL_operatorFrameActive = eFALSE;
            #ifdef EDP300_SPECIAL_FEATURES_HMI
            EDP300ModeRequestAccessToMode(eTRUE);
            #endif
        }

        // prepare menu frame variables
        LOCAL_cursorPosition = cursor;
        cursorL = ((TUSIGN16)newFrame->frameDefinition.menuFrame.firstItem_MSByte << 8) + (TUSIGN16)newFrame->frameDefinition.menuFrame.firstItem_LSByte;
        cursorH = ((TUSIGN16)newFrame->frameDefinition.menuFrame.lastItem_MSByte << 8) + (TUSIGN16)newFrame->frameDefinition.menuFrame.lastItem_LSByte;
        LOCAL_cursorPositionLimit = (TUSIGN8)(cursorH - cursorL);

        if (newFrame->frameDefinition.menuFrame.specialMenuFlag == 2)   // 2 = Signals View
        {
            // Signals View - adjust cursor to first signal included in signals view
            TUSIGN8 SignalsViewEnable;

            LOCAL_cursorPosition = 0;

            #ifdef HMI_SUPPORTS_SIGNALS_VALIDITY_TEST
            SignalsViewEnable = ValidityTestCheck(
				#ifdef HMI_SUPPORTS_DIRECT_ACCESS_FRAMES
				(FRAME_FORMAT_TYPE const*)NULL,
				#endif
				(TUSIGN16)FrameTableGetSignal(LOCAL_cursorPosition)->SignalsViewTest
				#ifdef VALIDITY_TEST_CALLER
				, SIGNALS_TEST_NOT_APPLICABLE
				#endif
			);
            #else
            // Files generated by an early version of HMIGen that does not support validity tests on signals view
            SignalsViewEnable = FrameTableGetSignal(LOCAL_cursorPosition)->SignalsViewEnable;
            #endif

            while ((LOCAL_cursorPosition <= LOCAL_cursorPositionLimit) && (SignalsViewEnable == 0))
            {
                LOCAL_cursorPosition ++;

                #ifdef HMI_SUPPORTS_SIGNALS_VALIDITY_TEST
                SignalsViewEnable = ValidityTestCheck((TUSIGN16)FrameTableGetSignal(LOCAL_cursorPosition)->SignalsViewTest
#ifdef VALIDITY_TEST_CALLER
					, SIGNALS_TEST_NOT_APPLICABLE
#endif
				);
                #else
                SignalsViewEnable = FrameTableGetSignal(LOCAL_cursorPosition)->SignalsViewEnable;
                #endif
            }

            if (LOCAL_cursorPosition > LOCAL_cursorPositionLimit)
            {
                LOCAL_cursorPosition = 0;
            }
        }
        #ifdef HMI_USES_COMMONDIAGNOSTICS
        else if ((newFrame->frameDefinition.menuFrame.specialMenuFlag == 5)     // 5 = Alarm History
              || (newFrame->frameDefinition.menuFrame.specialMenuFlag == 6))    // 6 = Secure Alarm History
        {
            // Alarm History - adjust cursor to first alarm that has history details
            cursor = 0;
            TINT16 alm = AdjusterFindFirstDiagHistoryEntry((TUSIGN8)(newFrame->frameDefinition.menuFrame.specialMenuFlag - 4));

            if (alm < 0)
            {
                LOCAL_cursorPosition = 0;
            }
            else
            {
                LOCAL_cursorPosition = (TUSIGN8)alm;
            }
        }
        #endif

        else    // 0 = std menu
                // 1 = Operator Menu
                // 3 = Diagnostics View
                // 4 = ARM Access level Selection
        {
            #ifndef DISABLE_BACK_MOVE_SELECT
            if (newFrame->frameDefinition.menuFrame.specialMenuFlag == 0)
            {
                LOCAL_mostRecentStandardMenu = newFrame;
            }
            #endif


            TBOOL CursorChanged = eFALSE;

//            while ((ValidityTestCheck((TUSIGN16)(FrameTableGetMenuItem((TUSIGN16)(LOCAL_cursorPosition + cursorL))->validTest)) == 0) && (loop < 2))
//            {
//                CursorChanged = eTRUE;
//                LOCAL_cursorPosition ++;
//                if (LOCAL_cursorPosition > LOCAL_cursorPositionLimit)
//                {
//                    LOCAL_cursorPosition = 0;
//                    loop ++;
//                }
//            }


            TUSIGN8 ValidityTestCheckResult = 0;
            MENU_ITEM_TYPE const *pMenuItem = FrameTableGetMenuItem((TUSIGN16)(LOCAL_cursorPosition + cursorL));
            if (pMenuItem)
            {
                ValidityTestCheckResult = ValidityTestCheck((TUSIGN16)pMenuItem->validTest
#ifdef VALIDITY_TEST_CALLER
					, SIGNALS_TEST_NOT_APPLICABLE
#endif
				);
            }

            while ((ValidityTestCheckResult == 0) && (loop < 2))
            {
                CursorChanged = eTRUE;
                LOCAL_cursorPosition ++;
                if (LOCAL_cursorPosition > LOCAL_cursorPositionLimit)
                {
                    LOCAL_cursorPosition = 0;
                    loop ++;
                }

                ValidityTestCheckResult = 0;
                pMenuItem = FrameTableGetMenuItem((TUSIGN16)(LOCAL_cursorPosition + cursorL));
                if (pMenuItem)
                {
                    ValidityTestCheckResult = ValidityTestCheck((TUSIGN16)(FrameTableGetMenuItem((TUSIGN16)(LOCAL_cursorPosition + cursorL))->validTest)
#ifdef VALIDITY_TEST_CALLER
						, SIGNALS_TEST_NOT_APPLICABLE
#endif
					);
                }
            }


            if (CursorChanged)
            {
                FrameMover_ResetFrameMemory((TUSIGN8)(FrameMover_GetFrameMemoryPointer() + 1));
            }
        }

        {
            TUSIGN8 c  = LOCAL_cursorPosition;
            TUSIGN8 cl = LOCAL_cursorPositionLimit;
            FrameTableAccessMenuPositionDetails(&(c), &cl, eFALSE);

            #if defined (TYPE_4_IMPLEMENTATION) || defined (TYPE_5_IMPLEMENTATION)
            FrameTableUpdateMenuPositionDetailsForTFT(c, cl, cursorL);
            #endif
        }
        returnVal = 1;
        break;

    #ifdef HMI_SUPPORTS_GRAPH_PARAM_FRAMES
    case FRAME_TYPE_GRAPH_PARAM_FRAME_1_NO_EDIT:
    case FRAME_TYPE_GRAPH_PARAM_FRAME_2_NO_EDIT:
        // prepare Progress parameter frame variables
        LOCAL_editEnabled = 0;
        LOCAL_cursorPosition = 0;
        returnVal = 1;
        LOCAL_operatorFrameActive = eFALSE;
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        EDP300ModeRequestAccessToMode(eTRUE);
        #endif
        break;
    #endif

    #ifdef HMI_SUPPORTS_WAVEFORM_FRAMES
    case FRAME_TYPE_WAVEFORM_FRAME:
        returnVal = 1;
        break;
    #endif

    #ifdef HMI_SUPPORTS_MATRIX_FRAMES
    case FRAME_TYPE_MATRIX_T_C_D:
    case FRAME_TYPE_MATRIX_X_Y_XY:
        Initialise_MatrixData(newFrame);
        returnVal = 1;
        break;
    #endif

    #ifdef HMI_SUPPORTS_LINEARIZER_FRAMES
    case FRAME_TYPE_LINEARIZER:
        Initialise_LinearizerData(newFrame);
        returnVal = 1;
        break;
    #endif



    case FRAME_TYPE_NUMERICAL_PARAM:
    case FRAME_TYPE_NUMERICAL_PARAM_NO_EDIT:
    case FRAME_TYPE_INTEGER_PARAM:
    case FRAME_TYPE_INTEGER_PARAM_NO_EDIT:
        // prepare numerical parameter frame variables
        LOCAL_editEnabled = 0;
        LOCAL_cursorPosition = 0;
        returnVal = 1;
        LOCAL_cursorPositionLimit = newFrame->frameDefinition.numericalParamFrame.attributes.maxCharacters + 1;

        #ifdef HMI_SUPPORTS_INTEGER_FRAMES
        if ((newFrame->frameType == FRAME_TYPE_INTEGER_PARAM) || (newFrame->frameType == FRAME_TYPE_INTEGER_PARAM_NO_EDIT))
        {
            TUSIGN8 resolution = newFrame->frameDefinition.numericalParamFrame.attributes.characterSet_dpPosn;
            AdjusterAdjustResolutionForCustomDP(&resolution);

            if (resolution != 0)
            {
                LOCAL_cursorPositionLimit ++;
            }
        }
        #endif

        LOCAL_operatorFrameActive = eFALSE;
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        EDP300ModeRequestAccessToMode(eTRUE);
        #endif
        break;

    #ifdef HMI_SUPPORTS_MANUAL_CALIBRATION
    case FRAME_TYPE_MANUAL_CALIBRATION:
        {

        TUSIGN8  calibrationStatus = HMI_CAL_STATUS_WAITING_FOR_STABILITY;

        #ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
        if (LOCAL_OutputHold_enable == eTRUE)
        {
            calibrationStatus = HMI_CAL_STATUS_SET_OUTPUT_HOLD;
        }
        #endif

        //set calibration state to HMI_CAL_STATUS_WAITING_FOR_STABILITY
        (void)AdjusterWriteAttribute((TUSIGN16)newFrame->frameDefinition.manualCalFrame.ssidx,
                                     (TUSIGN16)newFrame->frameDefinition.manualCalFrame.objidx_status,
                                     (TINT16)0,
                                     (void FAST *)&calibrationStatus);

        LOCAL_editEnabled = 0;
        LOCAL_cursorPosition = 0;
        returnVal = 1;

        #ifdef APA592_SPECIAL_FEATURES_HMI
        LOCAL_cursorPositionLimit = 10;
        #else
        LOCAL_cursorPositionLimit = 7;
        #endif

        LOCAL_operatorFrameActive = eFALSE;
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        EDP300ModeRequestAccessToMode(eTRUE);
        #endif
        }
        break;
    #endif

    #if defined(HMI_SUPPORTS_2PT_PH_CALIBRATION)
    case FRAME_TYPE_2_POINT_pH_CALIBRATION:
        {
        TWO_POINT_pH_CALIBRATION_FRAME_TYPE const *pFrameData = &(newFrame->frameDefinition.pHCalFrame);
        TUSIGN8 calibrationStatus;
        T_UNIT const SLOW *pSub = GetSubsystemPtr((T_SUBSYSTEM_IDX)pFrameData->ssidx);
        (void)pSub->Get(pSub,(TUSIGN16)pFrameData->objidx_status,0,(void FAST *)&calibrationStatus);
        if (calibrationStatus == HMI_CAL_STATUS_INACTIVE)
        {
            #ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
            if (LOCAL_OutputHold_enable == eTRUE)
            {
                calibrationStatus = HMI_CAL_STATUS_SET_OUTPUT_HOLD;
            }
            #endif

            calibrationStatus = HMI_CAL_STATUS_VIEW_BUFFER_TEMP;
            (void)pSub->Put(pSub,(TUSIGN16)pFrameData->objidx_status,0,(void FAST *)&calibrationStatus);
        }

        if((calibrationStatus == HMI_CAL_STATUS_VIEW_BUFFER_TEMP)
         ||(calibrationStatus == HMI_CAL_STATUS_EDIT_BUFFER_TEMP))
        {
            LOCAL_cursorPositionLimit = 6;
        }
        else
        {
            TUSIGN16 BufferValueObjectIndex;
            T_DO_ATTRIB_RANGE Range; // Pointer to range information
            TFLOAT abs_max,abs_min;

            if ((calibrationStatus == HMI_CAL_STATUS_VIEW_BUFFER_1) || (calibrationStatus == HMI_CAL_STATUS_EDIT_BUFFER_1))
            {
                BufferValueObjectIndex = pFrameData->objidx_buffer_1;
            }
            else
            {
                BufferValueObjectIndex = pFrameData->objidx_buffer_2;
            }

            pSub->GetAttributeDescription(pSub,BufferValueObjectIndex,0,&Range);

            abs_max = Range.range.flt.max < 0 ? (Range.range.flt.max * -1) : Range.range.flt.max;
            abs_min = Range.range.flt.min < 0 ? (Range.range.flt.min * -1) : Range.range.flt.min;
            if (abs_min > abs_max)  {abs_max = abs_min;}



            // calculate cursor position limit
            // calculate the number of dec places,
            // cursor position limit is number of dec places + 4 (add characters for Tens, Units & decimal point, then 1 more)
            TUSIGN8 edit_chars = 0;
            TUSIGN8 edit_decpt = (FrameTableGetSignal((TUSIGN8)pFrameData->ProcessSignal_1))->dpPosn;
            AdjusterAdjustResolutionForCustomDP(&edit_decpt);

            // calculate number of characters for buffer value
            if (edit_decpt != 0)
            {
                edit_chars = edit_decpt + 1; // characters reqd for decimal places and '.' symbol
            }

            if      (abs_max <  10.0f)  {edit_chars += 1;}  // character(s) reqd for units
            else if (abs_max < 100.0f)  {edit_chars += 2;}  // character(s) reqd for tens & units
            else if (abs_max < 1000.0f) {edit_chars += 3;}  // character(s) reqd for hundreds,tens & units
            else                        {edit_chars += 4;}  // character(s) reqd for thousands,hundreds,tens & units

            LOCAL_cursorPositionLimit = edit_chars + 1;
        }

        LOCAL_operatorFrameActive = eFALSE;
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        EDP300ModeRequestAccessToMode(eTRUE);
        #endif
        LOCAL_editEnabled = 0;
        LOCAL_cursorPosition = 0;
        returnVal = 1;
        }
        break;
    #endif

    #ifdef HMI_SUPPORTS_AUTO_CALIBRATION
    case FRAME_TYPE_AUTO_CALIBRATION:
        {
            //set calibration state to HMI_CAL_STATUS_WAITING_FOR_STANDARD_1
            if (FrameTableIsNavigationFromAutoCalAllowed() == eFALSE)
            {
                TUSIGN8 calibrationStatus = HMI_CAL_STATUS_WAITING_FOR_STANDARD_1;

                #ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
                if (LOCAL_OutputHold_enable == eTRUE)
                {
                    calibrationStatus = HMI_CAL_STATUS_SET_OUTPUT_HOLD;
                }
                #endif

                (void)AdjusterWriteAttribute((TUSIGN16)newFrame->frameDefinition.autoCalFrame.ssidx,
                                             (TUSIGN16)newFrame->frameDefinition.autoCalFrame.objidx_status,
                                             0,
                                             (void FAST *)&calibrationStatus);
            }

            LOCAL_editEnabled = 0;
            LOCAL_cursorPosition = 0;
            returnVal = 1;
            LOCAL_cursorPositionLimit = 7;
            LOCAL_operatorFrameActive = eFALSE;
            #ifdef EDP300_SPECIAL_FEATURES_HMI
            EDP300ModeRequestAccessToMode(eTRUE);
            #endif
        }
        break;
    #endif

    #ifdef HMI_SUPPORTS_IP_ADDRESS_FRAMES
        case FRAME_TYPE_IP_ADDRESS:
        case FRAME_TYPE_IP_ADDRESS_NO_EDIT:
        // prepare IP address parameter frame variables

        LOCAL_editEnabled = 0;
        LOCAL_cursorPosition = 0;
        returnVal = 1;
        LOCAL_cursorPositionLimit = 4;
        LOCAL_operatorFrameActive = eFALSE;
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        EDP300ModeRequestAccessToMode(eTRUE);
        #endif
	    break;
    #endif

    #ifdef HMI_SUPPORTS_TIME_DATE_PARAM_FRAMES
    case FRAME_TYPE_TIME_AND_DATE_PARAM:
    case FRAME_TYPE_TIME_AND_DATE_PARAM_NO_EDIT:
        // prepare time/date parameter frame variables

        LOCAL_editEnabled = 0;
        LOCAL_cursorPosition = 0;
        returnVal = 1;
        if (newFrame->frameDefinition.timeDateFrame.TimeAndOrDate == 0)
        {
            LOCAL_cursorPositionLimit = 6;
        }
        else
        {
            LOCAL_cursorPositionLimit = 3;
        }

        LOCAL_operatorFrameActive = eFALSE;
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        EDP300ModeRequestAccessToMode(eTRUE);
        #endif
	    break;
	#endif

    #ifdef HMI_SUPPORTS_BIT_ENUM_PARAM_FRAMES
    case FRAME_TYPE_BIT_ENUMERATED_PARAM:
    case FRAME_TYPE_BIT_ENUMERATED_PARAM_NO_EDIT:
        // prepare bit enumeration parameter frame variables
        LOCAL_editEnabled = 0;
        LOCAL_cursorPosition = 0;
        returnVal = 1;
        LOCAL_cursorPositionLimit = newFrame->frameDefinition.bitEnumParamFrame.numberOfBits;
        LOCAL_operatorFrameActive = eFALSE;
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        EDP300ModeRequestAccessToMode(eTRUE);
        #endif
	    break;
	#endif

    case FRAME_TYPE_STRING_PARAM:
    case FRAME_TYPE_STRING_PARAM_NO_EDIT:
    case FRAME_TYPE_STRING_PARAM_PACKED:
    case FRAME_TYPE_STRING_PARAM_PACKED_NO_EDIT:
#if defined (HMI_SUPPORTS_STANDARDASCII) || defined(HMI_SUPPORTS_PACKEDASCII)
        // prepare string parameter frame variables
/*
        #ifdef HMI_SUPPORTS_SECURITY_ACCESS
        if (newFrame->frameDefinition.stringParamFrame.specialStringFlag != 0)
        {
            LOCAL_editEnabled = 1;
        }
        else
        #endif
*/
        {
            LOCAL_editEnabled = 0;
        }
        LOCAL_cursorPosition = 0;
        returnVal = 1;
        LOCAL_cursorPositionLimit = newFrame->frameDefinition.stringParamFrame.attributes.maxCharacters;
        LOCAL_operatorFrameActive = eFALSE;
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        EDP300ModeRequestAccessToMode(eTRUE);
        #endif
        break;
#endif

    case FRAME_TYPE_ENUMERATED_PARAM:
    case FRAME_TYPE_ENUMERATED_PARAM_NO_EDIT:
    case FRAME_TYPE_ENUMERATED_PARAM_OVERRIDE_WP:
        // prepare enum parameter frame variables
        LOCAL_editEnabled = 0;
        LOCAL_cursorPosition = 0;
        returnVal = 1;
        LOCAL_operatorFrameActive = eFALSE;
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        EDP300ModeRequestAccessToMode(eTRUE);
        #endif
        break;

    case FRAME_TYPE_MANUAL_ADJUST:
    case FRAME_TYPE_AUTO_ADJUST:
    case FRAME_TYPE_AUTO_ADJUST_WITH_TIMER_AND_RESULT:
        // prepare auto/manual adjust parameter frame variables
        LOCAL_editEnabled = 0;
        LOCAL_cursorPosition = 0;
        returnVal = 1;
        LOCAL_operatorFrameActive = eFALSE;
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        EDP300ModeRequestAccessToMode(eTRUE);
        #endif

        #ifdef AZ200_SPECIAL_FEATURES_HMI
        if ((newFrame->frameType == FRAME_TYPE_MANUAL_ADJUST)
         && (newFrame->frameDefinition.adjParamFrame.value_ssIdx == CAL_IDX)
         && (newFrame->frameDefinition.adjParamFrame.adjvalue_objidx == CAL_IDX_PerformanceLogEntryIndex)
         && (newFrame->frameDefinition.adjParamFrame.adjvalue_attribidx == 0))
        {
            TUSIGN8  EntryIndex = 0;
            (void)AdjusterWriteAttribute((TUSIGN16)CAL_IDX, (TUSIGN16)CAL_IDX_PerformanceLogEntryIndex, 0, (void FAST *)&EntryIndex);
        }
        #endif
        break;

    case FRAME_TYPE_PROGRESS_BAR:
        // prepare Progress parameter frame variables
        LOCAL_editEnabled = 0;
        LOCAL_cursorPosition = 0;
        returnVal = 1;
        LOCAL_operatorFrameActive = eFALSE;
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        EDP300ModeRequestAccessToMode(eTRUE);
        #endif
        break;

    default:
        returnVal = 0;
        break;
    }

    if (returnVal == 1)
    {
        LOCAL_currentFrame = newFrame;
    }

    return returnVal;
}

/*!
 \brief         Enables editing of the data in the currently active frame
 \author        Roger Arnold
 \param         0 disable editing, 1 enable editing, other values do nothing
 \return        new edit enabled state - 0 editing disabled , 1 editing enabled
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
TUSIGN8 FrameTableEnableEdit(TUSIGN8 enable)
{
    if (enable == 0)
    {
        LOCAL_editEnabled = 0;
    }
    else if (enable == 1)
    {
        LOCAL_editEnabled = 1;
        LOCAL_cursorPosition = 0;
    }
    else
    {
        asm("nop");
    }
    return LOCAL_editEnabled;
}

/*!
 \brief         Returns the edit state of the data in the currently active frame
 \author        Roger Arnold
 \param
 \return        edit enabled state - 0 editing disabled , 1 editing enabled
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
TUSIGN8 FrameTableIsEditEnabled(void)
{
        return LOCAL_editEnabled;
}

/*!
 \brief         Returns the cursor position in the currently active frame
 \author        Roger Arnold
 \param
 \return        cursor position
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
TUSIGN8 FrameTableGetCursorPosition(void)
{
        return LOCAL_cursorPosition;
}

/*!
 \brief         Returns the maximum cursor position in the currently active frame
 \author        Roger Arnold
 \param
 \return        maximum cursor position
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
TUSIGN8 FrameTableGetCursorPositionLimit(void)
{
        return  LOCAL_cursorPositionLimit;
}

/*!
 \brief         Sets a cursor position in the currently active frame
                        Will allow the cursor position to be set to any value from 0 to the maximum cursor position (inclusive)
 \author        Roger Arnold
 \param
 \return        1 on success, 0 on any error (eg. new position > maximum cursor position) under error conditions the cursor position is not changed
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
TUSIGN8 FrameTableSetCursorPosition(TUSIGN8 position)
{
    TUSIGN8 returnVal;

    #ifdef HMI_USES_COMMONDIAGNOSTICS
    if ((LOCAL_currentFrame->frameDefinition.menuFrame.specialMenuFlag == 3)
     || (LOCAL_currentFrame->frameDefinition.menuFrame.specialMenuFlag == 5)
     || (LOCAL_currentFrame->frameDefinition.menuFrame.specialMenuFlag == 6))
    {
        LOCAL_cursorPosition = position;
        returnVal = 1;
    }
    else
    #endif
    {
        #ifdef EDP300_SPECIAL_FEATURES_HMI
        if (LOCAL_currentFrame->frameDefinition.menuFrame.specialMenuFlag == 7)
        {
            LOCAL_cursorPosition = position;
            returnVal = 1;
        }
        else
        #endif
        {
            if (position <= LOCAL_cursorPositionLimit)
            {
                LOCAL_cursorPosition = position;
                returnVal = 1;
            }
            else
            {
                returnVal = 0;
            }
        }
    }
    return returnVal;
}

TUSIGN8 FrameTableGetLanguageIndex(TUSIGN8 language)
{
    // Get string table number by cross referring language
    // If language selects an invalid string table then use 1st string table
    TUSIGN8 LanguageIndex = 0;
    
    if(servicePort.ServPortGetActivationStatusSRV() == SERVICEPORT_HMI_STATUS)
    {
#ifdef SUPPORT_OLD_HMI
        LanguageIndex = LanguageCrossRef[language];
#endif
    }
    else if(servicePort.ServPortGetActivationStatusSRV() == SERVICEPORT_SHMI_STATUS)
    {        
#ifdef SUPPORT_SHMI
        LanguageIndex = LanguageCrossRef_s[language];
#endif
    }



    if (LanguageIndex)
    {
        LanguageIndex --;
    }
    return LanguageIndex;
}


#if defined(COMMON_TOP_WORKS_NEW_FEATURES) && defined(HMI_USES_CUSTOM_LANGUAGES)

TUSIGN8 checkForCustomLanguage(TUSIGN8 stringTableID)
{
    TUSIGN8 returnVal = stringTableID;
    TBOOL   customRequested = eFALSE;
    TUSIGN8 CustomID = HMI_LANGUAGE_NOT_DEFINED;

    switch (stringTableID)
    {
    #ifndef LANGUAGE_20_INCLUDED_AS_STANDARD
    case 19:    customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_19_INCLUDED_AS_STANDARD
    case 18:    customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_18_INCLUDED_AS_STANDARD
    case 17:    customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_17_INCLUDED_AS_STANDARD
    case 16:    customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_16_INCLUDED_AS_STANDARD
    case 15:    customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_15_INCLUDED_AS_STANDARD
    case 14:    customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_14_INCLUDED_AS_STANDARD
    case 13:    customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_13_INCLUDED_AS_STANDARD
    case 12:    customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_12_INCLUDED_AS_STANDARD
    case 11:    customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_11_INCLUDED_AS_STANDARD
    case 10:    customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_10_INCLUDED_AS_STANDARD
    case 9:     customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_9_INCLUDED_AS_STANDARD
    case 8:     customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_8_INCLUDED_AS_STANDARD
    case 7:     customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_7_INCLUDED_AS_STANDARD
    case 6:     customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_6_INCLUDED_AS_STANDARD
    case 5:     customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_5_INCLUDED_AS_STANDARD
    case 4:     customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_4_INCLUDED_AS_STANDARD
    case 3:     customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_3_INCLUDED_AS_STANDARD
    case 2:     customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_2_INCLUDED_AS_STANDARD
    case 1:     customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    #ifndef LANGUAGE_1_INCLUDED_AS_STANDARD
    case 0;     customRequested = eTRUE; CustomID = stringTableID;      break;
    #endif
    default:    customRequested = eFALSE;                               break;
    }

    if (customRequested)
    {
        if (FrameTableGetLanguageIndex(hmi_dynamic_data.Customlanguage) == CustomID)
        {
            returnVal = CUSTOM_LANGUAGE_STRING_TABLE;
        }
        else
        {
            returnVal = 0;
        }
    }
    return returnVal;
}

#endif  // end of #if defined(COMMON_TOP_WORKS_NEW_FEATURES) && defined(HMI_USES_CUSTOM_LANGUAGES)


/*!
 \brief         Gets a text string from the string table (or sub-system)
 \author        Roger Arnold
 \param         id - identifies the text string
 \return        pointer to the text string or NULL if error (string invalid, cannot access sub-system)
                        if the configured language is invalid then the string for the default language is returned)
 \test          No details available
*/

const TUSIGN8 OK_string[3] = "OK";
TUSIGN8 libIndex_string[3] = "";

const TUSIGN8 *FrameTableGetString(TEXT_IDENTIFIER_TYPE id)
{
    return GetString(id, SFD_SIMPLE.language);
}

const TUSIGN8 *FrameTableGetStringSpecificLanguage(TEXT_IDENTIFIER_TYPE id, TUSIGN8 SpecificLanguage)
{
    return GetString(id, SpecificLanguage);
}
//#ifdef SUPPORT_SHMI
/*
Description: Get the string from string table. two string types may return.
param1: indicate the string type. 0----indicates a normal string; 0x82----indicates a string lib index
param2: input param. the string id defined by HMIGen tool.
param3: input param. the language used.
return: the return string. it can be a string or a string library index.
*/
const TUSIGN8* GetObjString_s(E_STRING_TYPE* pStringType, TEXT_IDENTIFIER_TYPE id, TUSIGN8 language)
{
    const TCHAR  *pString;
    TUSIGN16 libIdx;
    TUSIGN8 stringTableID;

    //set the default value
    switch (language)
    {
        case HMI_LANGUAGE_RUSSIAN:  
            *pStringType = STRING_TYPE_RUSSIAN;    
            break;
        
        case HMI_LANGUAGE_TURKISH:  
            *pStringType = STRING_TYPE_TURKISH;     
            break;
        
        case HMI_LANGUAGE_JAPANESE: 
            *pStringType = STRING_TYPE_KATAKANA;     
            break;

        case HMI_LANGUAGE_CHINESE: 
            *pStringType = STRING_TYPE_ASIAN;     
            break;    
        
        default:                    
            *pStringType = STRING_TYPE_EUROPEAN;     
            break;
    }
     

    if (id.attribIdx > MAX_STRINGS)
    {
        pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];
        *pStringType = STRING_TYPE_EUROPEAN;  
    }
    else if ((id.attribIdx == IDS_OK) && (language != HMI_LANGUAGE_CHINESE))
    {// if required string is "OK" then dont go to string tables        
        pString = (const TUSIGN8 *)OK_string;  
        *pStringType = STRING_TYPE_EUROPEAN;  
    }
    else
    {  
        libIdx = libIndexTable[id.attribIdx];
        if(libIdx!=0)
        {
            libIndex_string[0] = libIdx>>8;
            libIndex_string[1] = libIdx;
            libIndex_string[2] = '\0';
            pString = (const TCHAR*)libIndex_string;
            *pStringType = STRING_TYPE_LIBIDX;
        }
        else
        {
            pString = NULL;  //set default value 
            stringTableID = FrameTableGetLanguageIndex(language);
            
            switch (stringTableID)
            {
            #ifdef COMMON_TOP_WORKS_NEW_FEATURES        
                case 19:                
                #ifdef LANGUAGE_20_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s20)/sizeof(stringTable_s20[0])) 
                    {
                        pString = (const TUSIGN8 *)stringTable_s20[id.attribIdx];
                    } 
                    break;
                #endif
                    
                case 18:   
                #ifdef LANGUAGE_19_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s19)/sizeof(stringTable_s19[0])) 
                    {
                        pString = (const TUSIGN8 *)stringTable_s19[id.attribIdx];
                    } 
                    break;
                #endif
                
                case 17:    
                #ifdef LANGUAGE_18_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s18)/sizeof(stringTable_s18[0])) 
                    {
                        pString = (const TUSIGN8 *)stringTable_s18[id.attribIdx];
                    } 
                    break;
                #endif
                    
                case 16:  
                #ifdef LANGUAGE_17_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s17)/sizeof(stringTable_s17[0])) 
                    {
                        pString = (const TUSIGN8 *)stringTable_s17[id.attribIdx];
                    } 
                    break;
                #endif
                    
                case 15:  
                #ifdef LANGUAGE_16_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s16)/sizeof(stringTable_s16[0])) 
                    {
                        pString = (const TUSIGN8 *)stringTable_s16[id.attribIdx];
                    } 
                    break;
                #endif
                    
                case 14:    
                #ifdef LANGUAGE_15_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s15)/sizeof(stringTable_s15[0])) 
                    {
                        pString = (const TUSIGN8 *)stringTable_s15[id.attribIdx];
                    } 
                    break;
                #endif
                    
                case 13:  
                #ifdef LANGUAGE_14_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s14)/sizeof(stringTable_s14[0])) 
                    {
                        pString = (const TUSIGN8 *)stringTable_s14[id.attribIdx];
                    } 
                    break;
                #endif
                    
                case 12:     
                #ifdef LANGUAGE_13_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s13)/sizeof(stringTable_s13[0])) 
                    {
                        pString = (const TUSIGN8 *)stringTable_s13[id.attribIdx];
                    } 
                    break;
                #endif
                    
            #endif
                case 11:   
                #ifdef LANGUAGE_12_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s12)/sizeof(stringTable_s12[0])) 
                    {
                        pString = (const TUSIGN8 *)stringTable_s12[id.attribIdx];
                    } 
                    break;
                #endif
                    
                case 10:  
                #ifdef LANGUAGE_11_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s11)/sizeof(stringTable_s11[0])) 
                    {
                        pString = (const TUSIGN8 *)stringTable_s11[id.attribIdx];
                    } 
                    break;
                #endif
                    
                case 9:  
                #ifdef LANGUAGE_10_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s10)/sizeof(stringTable_s10[0])) 
                    {
                        pString = (const TUSIGN8 *)stringTable_s10[id.attribIdx];
                    } 
                    break;
                #endif
                    
                case 8:  
                #ifdef LANGUAGE_9_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s9)/sizeof(stringTable_s9[0]))  
                    {
                        pString = (const TUSIGN8 *)stringTable_s9[id.attribIdx];
                    }  
                    break;
                #endif
                    
                case 7:  
                #ifdef LANGUAGE_8_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s8)/sizeof(stringTable_s8[0]))  
                    {
                        pString = (const TUSIGN8 *)stringTable_s8[id.attribIdx];
                    }  
                    break;
                #endif
                    
                case 6:  
                #ifdef LANGUAGE_7_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s7)/sizeof(stringTable_s7[0]))  
                    {
                        pString = (const TUSIGN8 *)stringTable_s7[id.attribIdx];
                    }  
                    break;
                #endif
                    
                case 5:    
                #ifdef LANGUAGE_6_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s6)/sizeof(stringTable_s6[0]))  
                    {
                        pString = (const TUSIGN8 *)stringTable_s6[id.attribIdx];
                    }  
                    break;
                #endif
                    
                case 4: 
                #ifdef LANGUAGE_5_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s5)/sizeof(stringTable_s5[0]))  
                    {
                        pString = (const TUSIGN8 *)stringTable_s5[id.attribIdx];
                    }  
                    break;
                #endif
                    
                case 3:   
                #ifdef LANGUAGE_4_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s4)/sizeof(stringTable_s4[0]))  
                    {
                        pString = (const TUSIGN8 *)stringTable_s4[id.attribIdx];
                    }  
                    break;
                #endif
                    
                case 2:   
                #ifdef LANGUAGE_3_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s3)/sizeof(stringTable_s3[0]))  
                    {
                        pString = (const TUSIGN8 *)stringTable_s3[id.attribIdx];
                    }  
                    break;
                #endif
                    
                case 1: 
                #ifdef LANGUAGE_2_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= sizeof(stringTable_s2)/sizeof(stringTable_s2[0]))  
                    {
                        pString = (const TUSIGN8 *)stringTable_s2[id.attribIdx];
                    }  
                    break;
                #endif
                    
                case 0:    
                #ifdef LANGUAGE_1_INCLUDED_AS_STANDARD_S
                    if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_1)  
                    {
                        pString = (const TUSIGN8 *)stringTable_s1[id.attribIdx];
                        *pStringType = STRING_TYPE_EUROPEAN;
                    }  
                    break;
                #endif
                    
                default:
                    break;
            }

            
            if ( (pString==NULL)  //total table is not supported
              || ((pString[0] == 0xFF) && (pString[1] == 0x00))
              || (pString[0] == 0x00))  //is null
            {
                pString = (const TUSIGN8 *)stringTable_s1[id.attribIdx];
                *pStringType = STRING_TYPE_EUROPEAN;
            }
        }

    }

    return pString;
    
}

const TUSIGN8 *GetUnitString_s(E_STRING_TYPE * pStringType, TEXT_IDENTIFIER_TYPE id)
{
    const TUSIGN8  *pString;
    *pStringType = STRING_TYPE_EUROPEAN;       //set a default value

#if MAX_UNITS_1 > 0 || MAX_UNITS_2 > 0 || MAX_UNITS_3 > 0 || MAX_UNITS_4 > 0 || MAX_UNITS_5 > 0 || MAX_UNITS_6 > 0 || MAX_UNITS_7 > 0 || MAX_UNITS_8 > 0 || MAX_UNITS_9 > 0 || MAX_UNITS_10 > 0 || MAX_UNITS_11 > 0

    #ifdef HMI_SUPPORTS_16BIT_ENUMS
    TUSIGN16 offset = 0;
    #else
    TUSIGN8 offset = 0;
    #endif

    TEXT_IDENTIFIER_TYPE ID_of_invalid;
    ID_of_invalid.ssIdx = HMI_IDX;
    ID_of_invalid.objIdx = SS_HMI_OBJ_STRINGTABLE;
    ID_of_invalid.attribIdx = IDS_INVALID;
#endif

    if (id.ssIdx == HMI_IDX)
    {
        switch (id.objIdx)
        {        
        case SS_HMI_UNITS_TABLE_1:
            #if MAX_UNITS_1 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_1) && (unitsCrossReference_1[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_1)
                {                    
                    pString = GetObjString_s(pStringType, ID_of_invalid, HMI_LANGUAGE_ENGLISH);
                }
                else
                {
                    pString = (const TUSIGN8 *)unitsTable_1[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)pString,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(1);
                    pString = CustomUnitString_1;
                }
                #endif

            #else
                pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_2:
            #if MAX_UNITS_2 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_2) && (unitsCrossReference_2[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_2)
                {
                    pString = GetObjString_s(pStringType, ID_of_invalid, HMI_LANGUAGE_ENGLISH);
                }
                else
                {
                    pString = (const TUSIGN8 *)unitsTable_2[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)pString,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(2);
                    pString = CustomUnitString_2;
                }
                #endif

            #else
                pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_3:
            #if MAX_UNITS_3 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_3) && (unitsCrossReference_3[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_3)
                {
                    pString = GetObjString_s(pStringType, ID_of_invalid, HMI_LANGUAGE_ENGLISH);
                }
                else
                {
                    pString = (const TUSIGN8 *)unitsTable_3[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)pString,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(3);
                    pString = CustomUnitString_3;
                }
                #endif

            #else
                pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_4:
            #if MAX_UNITS_4 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_4) && (unitsCrossReference_4[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_4)
                {
                    pString = GetObjString_s(pStringType, ID_of_invalid, HMI_LANGUAGE_ENGLISH);
                }
                else
                {
                    pString = (const TUSIGN8 *)unitsTable_4[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)pString,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(4);
                    pString = CustomUnitString_4;
                }
                #endif

            #else
                pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_5:
            #if MAX_UNITS_5 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_5) && (unitsCrossReference_5[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_5)
                {
                    pString = GetObjString_s(pStringType, ID_of_invalid, HMI_LANGUAGE_ENGLISH);
                }
                else
                {
                    pString = (const TUSIGN8 *)unitsTable_5[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)pString,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(5);
                    pString = CustomUnitString_5;
                }
                #endif

            #else
                pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_6:
            #if MAX_UNITS_6 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_6) && (unitsCrossReference_6[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_6)
                {
                    pString = GetObjString_s(pStringType, ID_of_invalid, HMI_LANGUAGE_ENGLISH);
                }
                else
                {
                    pString = (const TUSIGN8 *)unitsTable_6[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)pString,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(6);
                    pString = CustomUnitString_6;
                }
                #endif

            #else
                pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_7:
            #if MAX_UNITS_7 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_7) && (unitsCrossReference_7[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_7)
                {
                    pString = GetObjString_s(pStringType, ID_of_invalid, HMI_LANGUAGE_ENGLISH);
                }
                else
                {
                    pString = (const TUSIGN8 *)unitsTable_7[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)pString,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(7);
                    pString = CustomUnitString_7;
                }
                #endif

            #else
                pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_8:
            #if MAX_UNITS_8 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_8) && (unitsCrossReference_8[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_8)
                {
                    pString = GetObjString_s(pStringType, ID_of_invalid, HMI_LANGUAGE_ENGLISH);
                }
                else
                {
                    pString = (const TUSIGN8 *)unitsTable_8[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)pString,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(8);
                    pString = CustomUnitString_8;
                }
                #endif

            #else
                pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_9:
            #if MAX_UNITS_9 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_9) && (unitsCrossReference_9[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_9)
                {
                    pString = GetObjString_s(pStringType, ID_of_invalid, HMI_LANGUAGE_ENGLISH);
                }
                else
                {
                    pString = (const TUSIGN8 *)unitsTable_9[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)pString,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(9);
                    pString = CustomUnitString_9;
                }
                #endif

            #else
                pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_10:
            #if MAX_UNITS_10 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_10) && (unitsCrossReference_10[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_10)
                {
                    pString = GetObjString_s(pStringType, ID_of_invalid, HMI_LANGUAGE_ENGLISH);
                }
                else
                {
                    pString = (const TUSIGN8 *)unitsTable_10[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)pString,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(10);
                    pString = CustomUnitString_10;
                }
                #endif

            #else
                pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_11:
            #if MAX_UNITS_11 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_11) && (unitsCrossReference_11[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_11)
                {
                    pString = GetObjString_s(pStringType, ID_of_invalid, HMI_LANGUAGE_ENGLISH);
                }
                else
                {
                    pString = (const TUSIGN8 *)unitsTable_11[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)pString,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(11);
                    pString = CustomUnitString_11;
                }
                #endif

            #else
                pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];
            #endif
            break;


        default:
            // string attribute from HMI
            // There are no string attributes in the HMI therefore error...
            pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];
            break;
        }
    }
    else
    {
        // id.ssIdx != SUBSYSTEM_HMI, access string from subsystem -TO-DO-
        pString = (const TUSIGN8 *)stringTable_s1[IDS_BLANK];    // TEST ONLY
    }
    return pString;
}

const TUSIGN8 *FrameTableGetStringSpecificLanguage_s(E_STRING_TYPE* pStringType, TEXT_IDENTIFIER_TYPE id, TUSIGN8 SpecificLanguage)
{
    if(id.objIdx==SS_HMI_OBJ_STRINGTABLE)
    {
        return GetObjString_s(pStringType, id, SpecificLanguage);
    }
    else
    {
        return GetUnitString_s(pStringType, id);
    }
}

//#endif

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif

const TUSIGN8 *GetString(TEXT_IDENTIFIER_TYPE id, TUSIGN8 language)
{
    const TUSIGN8  *stringAddress;
    TUSIGN8 stringTableID;

#if MAX_UNITS_1 > 0 || MAX_UNITS_2 > 0 || MAX_UNITS_3 > 0 || MAX_UNITS_4 > 0 || MAX_UNITS_5 > 0 || MAX_UNITS_6 > 0 || MAX_UNITS_7 > 0 || MAX_UNITS_8 > 0 || MAX_UNITS_9 > 0 || MAX_UNITS_10 > 0 || MAX_UNITS_11 > 0

    #ifdef HMI_SUPPORTS_16BIT_ENUMS
    TUSIGN16 offset = 0;
    #else
    TUSIGN8 offset = 0;
    #endif


    TEXT_IDENTIFIER_TYPE ID_of_invalid;
    ID_of_invalid.ssIdx = HMI_IDX;
    ID_of_invalid.objIdx = SS_HMI_OBJ_STRINGTABLE;
    ID_of_invalid.attribIdx = IDS_INVALID;
#endif

    if (id.ssIdx == HMI_IDX)
    {
        switch (id.objIdx)
        {
        case SS_HMI_OBJ_STRINGTABLE:    // access string from string table

            stringTableID = FrameTableGetLanguageIndex(language);

            if (id.attribIdx > MAX_STRINGS)
            {
                stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];
            }
            else if ((id.attribIdx == IDS_OK) && (language != HMI_LANGUAGE_CHINESE))
            {
                // if required string is "OK" then dont go to string tables
                stringAddress = (const TUSIGN8 *)OK_string;
            }
            else
            {

                #if defined(COMMON_TOP_WORKS_NEW_FEATURES) && defined(HMI_USES_CUSTOM_LANGUAGES)

                stringTableID = checkForCustomLanguage(stringTableID);

                #endif
                stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];

                switch (stringTableID)
                {
                #ifdef COMMON_TOP_WORKS_NEW_FEATURES
                #ifdef HMI_USES_CUSTOM_LANGUAGES
                case CUSTOM_LANGUAGE_STRING_TABLE:  if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_21) {stringAddress = (const TUSIGN8 *)stringTable_21[id.attribIdx];} break;
                #endif
                case 19:                            if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_20) {stringAddress = (const TUSIGN8 *)stringTable_20[id.attribIdx];} break;
                case 18:                            if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_19) {stringAddress = (const TUSIGN8 *)stringTable_19[id.attribIdx];} break;
                case 17:                            if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_18) {stringAddress = (const TUSIGN8 *)stringTable_18[id.attribIdx];} break;
                case 16:                            if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_17) {stringAddress = (const TUSIGN8 *)stringTable_17[id.attribIdx];} break;
                case 15:                            if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_16) {stringAddress = (const TUSIGN8 *)stringTable_16[id.attribIdx];} break;
                case 14:                            if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_15) {stringAddress = (const TUSIGN8 *)stringTable_15[id.attribIdx];} break;
                case 13:                            if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_14) {stringAddress = (const TUSIGN8 *)stringTable_14[id.attribIdx];} break;
                case 12:                            if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_13) {stringAddress = (const TUSIGN8 *)stringTable_13[id.attribIdx];} break;
                #endif
                case 11:                            if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_12) {stringAddress = (const TUSIGN8 *)stringTable_12[id.attribIdx];} break;
                case 10:                            if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_11) {stringAddress = (const TUSIGN8 *)stringTable_11[id.attribIdx];} break;
                case 9:                             if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_10) {stringAddress = (const TUSIGN8 *)stringTable_10[id.attribIdx];} break;
                case 8:                             if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_9)  {stringAddress = (const TUSIGN8 *)stringTable_9[id.attribIdx];}  break;
                case 7:                             if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_8)  {stringAddress = (const TUSIGN8 *)stringTable_8[id.attribIdx];}  break;
                case 6:                             if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_7)  {stringAddress = (const TUSIGN8 *)stringTable_7[id.attribIdx];}  break;
                case 5:                             if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_6)  {stringAddress = (const TUSIGN8 *)stringTable_6[id.attribIdx];}  break;
                case 4:                             if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_5)  {stringAddress = (const TUSIGN8 *)stringTable_5[id.attribIdx];}  break;
                case 3:                             if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_4)  {stringAddress = (const TUSIGN8 *)stringTable_4[id.attribIdx];}  break;
                case 2:                             if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_3)  {stringAddress = (const TUSIGN8 *)stringTable_3[id.attribIdx];}  break;
                case 1:                             if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_2)  {stringAddress = (const TUSIGN8 *)stringTable_2[id.attribIdx];}  break;
                default:                            if (id.attribIdx <= MAX_STRINGS_STRING_TABLE_1)  {stringAddress = (const TUSIGN8 *)stringTable_1[id.attribIdx];}  break;
                }

                if ((stringAddress[0] == 0xFF) && (stringAddress[1] == 0x00))
                {
                    stringAddress = (const TUSIGN8 *)stringTable_1[id.attribIdx];
                }

                #ifdef HMI_USES_INDIRECT_TEXT

                TUSIGN16 i = 0;
                TBOOL match = eFALSE;

                while ((i < N_STRINGS_CONTAINING_INDIRECT_TEXT) && (!match))
                {
                    if (id.attribIdx == indirectTextStringRefTable[i])
                    {
                        match = eTRUE;
                    }
                    else
                    {
                        i ++;
                    }
                }

                if (match)
                {
                    LOCAL_derivedString[0] = 0x00;

                    TUSIGN8 iStrIdx = 0;
                    TUSIGN8 oStrIdx = 0;
                    TUSIGN8 length = (TUSIGN8)strlen((const char *)stringAddress);

                    // Get characters preceeding the indirect text
                    while ((stringAddress[iStrIdx+0] != '*')
                        && (stringAddress[iStrIdx+1] != 'E')
                        && (stringAddress[iStrIdx+2] != 'N')
                        && (stringAddress[iStrIdx+3] != 'U')
                        && (stringAddress[iStrIdx+4] != 'M')
                        && (iStrIdx < length)
                        && (oStrIdx < 20))
                    {
                        LOCAL_derivedString[oStrIdx] = stringAddress[iStrIdx];
                        LOCAL_derivedString[oStrIdx+1] = 0x00;
                        oStrIdx++;
                        iStrIdx++;
                    }

                    // Get the Enum Reference
                    iStrIdx += 5; // point to first char of emun ref - Skip past "*ENUM"

                    TUSIGN16 TableRef = 0;

                    while ((stringAddress[iStrIdx] != '*')
                        && (iStrIdx < length))
                    {
                        TableRef *= 10;

                        if ((stringAddress[iStrIdx] >= '0') && (stringAddress[iStrIdx] <= '9'))
                        {
                            TableRef += stringAddress[iStrIdx] - '0';
                        }
                        iStrIdx++;
                    }

                    // Get the enumerated text & add to derivedString
                    ADJUST_DATA tVal;
                    TUSIGN8 tType;

                    if (AdjusterGetEnumValue((TUSIGN16)IndirectTextIdentificationTable[TableRef].ssIdx,
                                             (TUSIGN16)IndirectTextIdentificationTable[TableRef].objIdx,
                                             (TUSIGN8)IndirectTextIdentificationTable[TableRef].attIdx,
                                             &tVal,
                                             &tType) == (TUSIGN16)OK)
                    {
                        TUSIGN16 tableOffset = IndirectTextIdentificationTable[TableRef].firstItem + tVal.data_8;
                        TEXT_IDENTIFIER_TYPE IndirectTextIdentifier;
                        IndirectTextIdentifier.ssIdx = (TUSIGN8)HMI_IDX;
                        IndirectTextIdentifier.objIdx = (TUSIGN8)SS_HMI_OBJ_STRINGTABLE;
                        IndirectTextIdentifier.attribIdx = (STR_REF)FrameTableGetEnumItem(tableOffset);
                        const TUSIGN8 *pEnumeratedText = GetString(IndirectTextIdentifier, language);
                        TUSIGN8 EnumeratedTextLength = (TUSIGN8)strlen((const char *)pEnumeratedText);
                        TUSIGN8 eStrIdx = 0;

                        while ((eStrIdx < EnumeratedTextLength)
                            && (oStrIdx < 20))
                        {
                            LOCAL_derivedString[oStrIdx] = pEnumeratedText[eStrIdx];
                            LOCAL_derivedString[oStrIdx+1] = 0x00;
                            oStrIdx++;
                            eStrIdx++;
                        }
                    }

                    // Get characters following the indirect text
                    iStrIdx ++; // point to first char following the indirect text - Skip past "*"

                    while ((iStrIdx < length)
                        && (oStrIdx < 20))
                    {
                        LOCAL_derivedString[oStrIdx] = stringAddress[iStrIdx];
                        LOCAL_derivedString[oStrIdx+1] = 0x00;
                        oStrIdx++;
                        iStrIdx++;
                    }

                    stringAddress = LOCAL_derivedString;
                }
                #endif  // end of #ifdef HMI_USES_INDIRECT_TEXT
            }
            break;

        case SS_HMI_UNITS_TABLE_1:
            #if MAX_UNITS_1 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_1) && (unitsCrossReference_1[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_1)
                {
                    stringAddress = FrameTableGetString(ID_of_invalid);
                }
                else
                {
                    stringAddress = (const TUSIGN8 *)unitsTable_1[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)stringAddress,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(1);
                    stringAddress = CustomUnitString_1;
                }
                #endif

            #else
                stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_2:
            #if MAX_UNITS_2 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_2) && (unitsCrossReference_2[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_2)
                {
                    stringAddress = FrameTableGetString(ID_of_invalid);
                }
                else
                {
                    stringAddress = (const TUSIGN8 *)unitsTable_2[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)stringAddress,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(2);
                    stringAddress = CustomUnitString_2;
                }
                #endif

            #else
                stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_3:
            #if MAX_UNITS_3 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_3) && (unitsCrossReference_3[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_3)
                {
                    stringAddress = FrameTableGetString(ID_of_invalid);
                }
                else
                {
                    stringAddress = (const TUSIGN8 *)unitsTable_3[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)stringAddress,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(3);
                    stringAddress = CustomUnitString_3;
                }
                #endif

            #else
                stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_4:
            #if MAX_UNITS_4 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_4) && (unitsCrossReference_4[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_4)
                {
                    stringAddress = FrameTableGetString(ID_of_invalid);
                }
                else
                {
                    stringAddress = (const TUSIGN8 *)unitsTable_4[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)stringAddress,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(4);
                    stringAddress = CustomUnitString_4;
                }
                #endif

            #else
                stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_5:
            #if MAX_UNITS_5 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_5) && (unitsCrossReference_5[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_5)
                {
                    stringAddress = FrameTableGetString(ID_of_invalid);
                }
                else
                {
                    stringAddress = (const TUSIGN8 *)unitsTable_5[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)stringAddress,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(5);
                    stringAddress = CustomUnitString_5;
                }
                #endif

            #else
                stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_6:
            #if MAX_UNITS_6 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_6) && (unitsCrossReference_6[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_6)
                {
                    stringAddress = FrameTableGetString(ID_of_invalid);
                }
                else
                {
                    stringAddress = (const TUSIGN8 *)unitsTable_6[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)stringAddress,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(6);
                    stringAddress = CustomUnitString_6;
                }
                #endif

            #else
                stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_7:
            #if MAX_UNITS_7 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_7) && (unitsCrossReference_7[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_7)
                {
                    stringAddress = FrameTableGetString(ID_of_invalid);
                }
                else
                {
                    stringAddress = (const TUSIGN8 *)unitsTable_7[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)stringAddress,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(7);
                    stringAddress = CustomUnitString_7;
                }
                #endif

            #else
                stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_8:
            #if MAX_UNITS_8 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_8) && (unitsCrossReference_8[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_8)
                {
                    stringAddress = FrameTableGetString(ID_of_invalid);
                }
                else
                {
                    stringAddress = (const TUSIGN8 *)unitsTable_8[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)stringAddress,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(8);
                    stringAddress = CustomUnitString_8;
                }
                #endif

            #else
                stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_9:
            #if MAX_UNITS_9 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_9) && (unitsCrossReference_9[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_9)
                {
                    stringAddress = FrameTableGetString(ID_of_invalid);
                }
                else
                {
                    stringAddress = (const TUSIGN8 *)unitsTable_9[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)stringAddress,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(9);
                    stringAddress = CustomUnitString_9;
                }
                #endif

            #else
                stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_10:
            #if MAX_UNITS_10 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_10) && (unitsCrossReference_10[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_10)
                {
                    stringAddress = FrameTableGetString(ID_of_invalid);
                }
                else
                {
                    stringAddress = (const TUSIGN8 *)unitsTable_10[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)stringAddress,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(10);
                    stringAddress = CustomUnitString_10;
                }
                #endif

            #else
                stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];
            #endif
            break;

        case SS_HMI_UNITS_TABLE_11:
            #if MAX_UNITS_11 > 0
                // convert id.attribIdx into units table offset
                while ((offset < MAX_UNITS_11) && (unitsCrossReference_11[offset] != id.attribIdx))
                {
                    offset ++;
                }

                if (offset >= MAX_UNITS_11)
                {
                    stringAddress = FrameTableGetString(ID_of_invalid);
                }
                else
                {
                    stringAddress = (const TUSIGN8 *)unitsTable_11[offset];
                }

                #ifdef HMI_SUPPORTS_CUSTOM_UNITS
                if (strcmp((const char*)stringAddress,"*CUSTOM*") == 0)
                {
                    GetCustomUnitString(11);
                    stringAddress = CustomUnitString_11;
                }
                #endif

            #else
                stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];
            #endif
            break;


        default:
            // string attribute from HMI
            // There are no string attributes in the HMI therefore error...
            stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];
            break;
        }
    }
    else
    {
        // id.ssIdx != SUBSYSTEM_HMI, access string from subsystem -TO-DO-
        stringAddress = (const TUSIGN8 *)stringTable_1[IDS_BLANK];    // TEST ONLY
    }
    return stringAddress;
}


#ifdef HMI_SUPPORTS_CUSTOM_UNITS
void GetCustomUnitString(TUSIGN8 UnitNumber)
{
    // Get the object mapped to the custom unit string
    TUSIGN8 customUnitString[21];
    T_SUBSYSTEM_IDX     mappedSubsystem;
    TUSIGN16            mappedObject;
    TUSIGN8*            pResult;

    switch (UnitNumber)
    {
    case 11:    mappedSubsystem = CUSTOM_UNIT_11_MAPPED_SUBSYSTEM;  mappedObject = CUSTOM_UNIT_11_MAPPED_OBJECT;    pResult = CustomUnitString_11;  break;
    case 10:    mappedSubsystem = CUSTOM_UNIT_10_MAPPED_SUBSYSTEM;  mappedObject = CUSTOM_UNIT_10_MAPPED_OBJECT;    pResult = CustomUnitString_10;  break;
    case 9:     mappedSubsystem = CUSTOM_UNIT_9_MAPPED_SUBSYSTEM;   mappedObject = CUSTOM_UNIT_9_MAPPED_OBJECT;     pResult = CustomUnitString_9;   break;
    case 8:     mappedSubsystem = CUSTOM_UNIT_8_MAPPED_SUBSYSTEM;   mappedObject = CUSTOM_UNIT_8_MAPPED_OBJECT;     pResult = CustomUnitString_8;   break;
    case 7:     mappedSubsystem = CUSTOM_UNIT_7_MAPPED_SUBSYSTEM;   mappedObject = CUSTOM_UNIT_7_MAPPED_OBJECT;     pResult = CustomUnitString_7;   break;
    case 6:     mappedSubsystem = CUSTOM_UNIT_6_MAPPED_SUBSYSTEM;   mappedObject = CUSTOM_UNIT_6_MAPPED_OBJECT;     pResult = CustomUnitString_6;   break;
    case 5:     mappedSubsystem = CUSTOM_UNIT_5_MAPPED_SUBSYSTEM;   mappedObject = CUSTOM_UNIT_5_MAPPED_OBJECT;     pResult = CustomUnitString_5;   break;
    case 4:     mappedSubsystem = CUSTOM_UNIT_4_MAPPED_SUBSYSTEM;   mappedObject = CUSTOM_UNIT_4_MAPPED_OBJECT;     pResult = CustomUnitString_4;   break;
    case 3:     mappedSubsystem = CUSTOM_UNIT_3_MAPPED_SUBSYSTEM;   mappedObject = CUSTOM_UNIT_3_MAPPED_OBJECT;     pResult = CustomUnitString_3;   break;
    case 2:     mappedSubsystem = CUSTOM_UNIT_2_MAPPED_SUBSYSTEM;   mappedObject = CUSTOM_UNIT_2_MAPPED_OBJECT;     pResult = CustomUnitString_2;   break;
    default:    mappedSubsystem = CUSTOM_UNIT_1_MAPPED_SUBSYSTEM;   mappedObject = CUSTOM_UNIT_1_MAPPED_OBJECT;     pResult = CustomUnitString_1;   break;
    }

    T_UNIT const SLOW *pSub = GetSubsystemPtr(mappedSubsystem);
    pSub->Get(pSub,mappedObject,(TINT16)WHOLE_OBJECT,(void FAST *)&customUnitString);

    // Make the string 8 characters in length
    while(strlen((char*)customUnitString) < 8)
    {
        strcat((char*)customUnitString," ");
    }
    customUnitString[8] = ' ';
    customUnitString[9] = 0x00;

    // Append "*CUSTOM*"
    strcat((char *)customUnitString,"*CUSTOM*");
    customUnitString[17] = 0x00;

    // Copy the resultant string to the local store
    strcpy((char *)pResult,(const char *)&customUnitString);
}
#endif

/*!
 \brief         Gets an item from the Enum table
 \author        Roger Arnold
 \param         TUSIGN16 enumItem - index in the enum Table
 \return        STR_REF the selected item from the menu table
 \test          No details available
*/
// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
STR_REF FrameTableGetEnumItem(TUSIGN16 enumItem)
{
    return enumTable_HMI[enumItem];
}

/*!
 \brief         Gets an item from the menu table
 \author        Roger Arnold
 \param         T_USIGN16 menuItem - index in the menu Table
 \return        pointer to the item in the menu table, if error a NULL pointer is returned
 \test          No details available
*/
// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
MENU_ITEM_TYPE const *FrameTableGetMenuItem(TUSIGN16 menuItem)
{
MENU_ITEM_TYPE const * returnVal;

    if (menuItem >= sizeof(menuTable)/sizeof(MENU_ITEM_TYPE))
    {
        returnVal = NULL;
    }
    else
    {
        returnVal = &(menuTable[menuItem]);
    }
    return returnVal;
}

/*!
 \brief         Gets a character Set
 \author        Roger Arnold
 \param         T_USIGN8 charSet - identifies the required character set
 \return        pointer to the first character in the selected character set, if error(invalid Character Set) a NULL pointer is returned
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
TUSIGN8 const *FrameTableGetCharacterSet(TUSIGN8 charSet)
{
    TUSIGN8 const * returnVal;

    switch (charSet)
    {
    case CHARACTER_SET_LATIN1:                  returnVal = CharacterSet_Latin1;             break;
    case CHARACTER_SET_STANDARD_AND_TURKISH:    returnVal = CharacterSet_StandardAndTurkish;    break;
    case CHARACTER_SET_TURKISH:                 returnVal = CharacterSet_Turkish;               break;
    case CHARACTER_SET_STANDARD_AND_KATAKANA:   returnVal = CharacterSet_StandardAndKatakana;   break;
    case CHARACTER_SET_KATAKANA:                returnVal = CharacterSet_Katakana;              break;
    case CHARACTER_SET_STANDARD_AND_RUSSIAN:    returnVal = CharacterSet_StandardAndRussian;    break;
    case CHARACTER_SET_RUSSIAN:                 returnVal = CharacterSet_Russian;               break;
    case CHARACTER_SET_PASSWORD:                returnVal = CharacterSet_Password;              break;
    case CHARACTER_SET_NUMERIC:                 returnVal = CharacterSet_Numeric;               break;
    case CHARACTER_SET_FILENAME:                returnVal = CharacterSet_Filename;              break;
    case CHARACTER_SET_EXTENDED:                returnVal = CharacterSet_Extended;              break;
    case CHARACTER_SET_STANDARD:                returnVal = CharacterSet_Standard;              break;
    case CHARACTER_SET_PACKED:                  returnVal = CharacterSet_Packed;                break;
    default:                                    returnVal = NULL;                               break;
    }

    return returnVal;
}

TUSIGN8 FrameTableGetExtendedCharacterPage(TUSIGN8 charSet)
{
    TUSIGN8 extendedCharacterPage;

    switch (charSet)
    {
    case CHARACTER_SET_STANDARD_AND_TURKISH:
    case CHARACTER_SET_TURKISH:             extendedCharacterPage = HMI_EXTENDED_CHARACTER_PAGE_TURKISH;    break;

    case CHARACTER_SET_STANDARD_AND_KATAKANA:
    case CHARACTER_SET_KATAKANA:            extendedCharacterPage = HMI_EXTENDED_CHARACTER_PAGE_KATAKANA;   break;

    case CHARACTER_SET_STANDARD_AND_RUSSIAN:
    case CHARACTER_SET_RUSSIAN:             extendedCharacterPage = HMI_EXTENDED_CHARACTER_PAGE_RUSSIAN;    break;

    case CHARACTER_SET_LATIN1:              extendedCharacterPage = HMI_EXTENDED_CHARACTER_PAGE_LATIN1;     break;

    case CHARACTER_SET_PASSWORD:
    case CHARACTER_SET_NUMERIC:
    case CHARACTER_SET_FILENAME:
    case CHARACTER_SET_EXTENDED:
    case CHARACTER_SET_STANDARD:
    case CHARACTER_SET_PACKED:              extendedCharacterPage = HMI_EXTENDED_CHARACTER_PAGE_EUROPEAN;   break;

    default:                                extendedCharacterPage = HMI_EXTENDED_CHARACTER_PAGE_EUROPEAN;   break;
    }

    return extendedCharacterPage;
}

TUSIGN8 FrameTableGetStringObjectExtendedCharacterPage(ATTRIB_IDENTIFIER_TYPE StringObject)
{
    TUSIGN8 i = 0;
    TUSIGN8 extendedCharacterPage = HMI_EXTENDED_CHARACTER_PAGE_EUROPEAN;
    TBOOL extendedCharacterPageFound = eFALSE;

    while ((StringObjectExtensionPageTable[i].ssIdx  != 0xFF)
        && (StringObjectExtensionPageTable[i].objIdx != 0xFF)
        && (!extendedCharacterPageFound))
    {
        if ((StringObjectExtensionPageTable[i].ssIdx  == StringObject.ssIdx)
         && (StringObjectExtensionPageTable[i].objIdx == StringObject.objIdx))
        {
            extendedCharacterPage = StringObjectExtensionPageTable[i].extendedCharacterPage;
            extendedCharacterPageFound = eTRUE;
        }
        i ++;
    }
    return extendedCharacterPage;
}

/*!
 \brief         Gets the id of a part of a config icon
 \author        Roger Arnold
 \param         TUSIGN8 icon - identifies the required icon
                TUSIGN8 posn - identifies which part of the icon
 \return        the id of the selected part of the selected icon
 \test          No details available
*/
// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
TUSIGN8 FrameTableGetConfigIconPart(TUSIGN8 icon, TUSIGN8 posn)
{
    TUSIGN8 iconPart;

    if ((icon > LAST_ICON) || (posn > 5))
    {
        iconPart = ICON_PART_BLANK;
    }
    else
    {
        iconPart = icon-1;
        iconPart = iconTable[iconPart][posn];
    }
    return iconPart;
}

/*!
 \brief         Gets the address of an icon part
 \author        Roger Arnold
 \param         TUSIGN8 *pIconPart - identifies the required icon part
 \return        pointer to the first byte of the selected icon, if error(invalid icon number) a NULL pointer is returned
 \test          No details available
*/
// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TUSIGN8 const *FrameTableGetConfigIconAddress(TUSIGN8 *pIconPart)
{
    TUSIGN8 const * returnVal;
    TUSIGN8 iconPart = *pIconPart;

    if (iconPart <= ICON_PART_MAGNIFY_C2)
    {
        // pre-defined icon
        // do not change IconPart
        // return NULL so that IconPart will be used
        returnVal = NULL;
    }

    #pragma diag_suppress=Pe186
    else if ((iconPart >= FIRST_ADDED_ICON_PART) && (iconPart <= LAST_ADDED_ICON_PART))
    #pragma diag_default=Pe186
    {
        // configurable icon
        // return address of the first byte of the selected Icon part
        TUSIGN8 const *iconAddr;
        iconPart -= FIRST_ADDED_ICON_PART;
        iconAddr = &config_icon[iconPart][0];
        returnVal = iconAddr;
    }
    else
    {
        // invalid icon number
        // change IconPart to "BLANK"
        // return NULL so that IconPart will be used
        *pIconPart = ICON_PART_BLANK;
        returnVal = NULL;
    }
    return returnVal;
}

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
SIGNAL_TABLE_TYPE const *FrameTableGetSignal(TUSIGN8 signal)
{
        if (signal >= MAX_SIGNALS)
        {
            signal = 0;
        }

        return &(signalTable[signal]);
}

#if defined(SECOND_OPERATOR_PAGE) || defined(THIRD_OPERATOR_PAGE) || defined(FOURTH_OPERATOR_PAGE) || defined(FIFTH_OPERATOR_PAGE) || defined(SIXTH_OPERATOR_PAGE)

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
void FrameTableEnableAutoscroll(void)
{
    if (SFD_MULTI_OP.autoscrollEnable == eTRUE)
    {
        LOCAL_autoscroll = eTRUE;
    }
}

// this function not size optimized beyond medium
#ifdef OPTIMIZE_V3_4
#pragma optimize=size medium
#else
#pragma optimize=z 6
#endif
void FrameTableDisableAutoscroll(void)
{
    LOCAL_autoscroll = eFALSE;
}

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TBOOL FrameTableIsAutoscrollEnabled(void)
{
    TBOOL returnVal = eFALSE;

    if (SFD_MULTI_OP.autoscrollEnable == eTRUE)
    {
        returnVal = LOCAL_autoscroll;
    }
    return returnVal;
}

#endif


// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TBOOL FrameTableGetAutoScrollState(TUSIGN8 instance)
{
    TBOOL returnVal = eFALSE;

#ifdef HMI_SUPPORTS_SERVICEPORT
    if (instance == HMI_LOCAL_INSTANCE)
    {
        returnVal = FrameTableLocal_1.autoscroll;
    }
    else if (instance == HMI_REMOTE_INSTANCE)
    {
        returnVal = FrameTableLocal_2.autoscroll;
    }
#else
    if (instance == HMI_LOCAL_INSTANCE)
    {
        returnVal = autoscroll;
    }
#endif
    else
    {
        returnVal = eFALSE;
    }

    return returnVal;
}

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TUSIGN8 FrameTableGetOperatorPageNumber(TUSIGN8 instance)
{
    TUSIGN8 returnVal = 0;
    FRAME_FORMAT_TYPE const *pFrame;
#ifdef HMI_SUPPORTS_SERVICEPORT
    if (instance == HMI_LOCAL_INSTANCE)
    {
        pFrame = FrameTableLocal_1.currentFrame;
    }
    else if (instance == HMI_REMOTE_INSTANCE)
    {
        pFrame = FrameTableLocal_2.currentFrame;
    }
#else
    if (instance == HMI_LOCAL_INSTANCE)
    {
        pFrame = currentFrame;
    }
#endif
    else
    {
        pFrame = NULL;
    }

    if (pFrame)
    {
        if (pFrame->frameType == FRAME_TYPE_OPERATOR)
        {
            returnVal = pFrame->frameDefinition.operatorFrame.frameNumber;
        }
    }
    return returnVal;
}

TBOOL FrameTableSetStartupFrame(TUSIGN8 instance, TBOOL autoscrollState, TUSIGN8 operatorPage)
{
    TBOOL returnVal = eTRUE;
    TUSIGN8 displayMode = HMI_DISPLAY_MODE_OFF;
    // check that the required operator page is valid
    #pragma diag_suppress=Pm060
    switch (operatorPage)
    {
    case 1:     displayMode = SFD_SIMPLE.displayMode_1;     break;

    #ifdef SECOND_OPERATOR_PAGE
    case 2:     displayMode = SFD_MULTI_OP.displayMode_2;   break;
    #endif
    #ifdef THIRD_OPERATOR_PAGE
    case 3:     displayMode = SFD_MULTI_OP.displayMode_3;   break;
    #endif
    #ifdef FOURTH_OPERATOR_PAGE
    case 4:     displayMode = SFD_MULTI_OP.displayMode_4;   break;
    #endif
    #ifdef FIFTH_OPERATOR_PAGE
    case 5:     displayMode = SFD_MULTI_OP.displayMode_5;   break;
    #endif
    #ifdef SIXTH_OPERATOR_PAGE
    case 6:     displayMode = SFD_MULTI_OP.displayMode_6;   break;
    #endif
    default:    displayMode = HMI_DISPLAY_MODE_OFF;         break;
    }
    #pragma diag_default=Pm060

    if ((displayMode == HMI_DISPLAY_MODE_OFF) || (displayMode > HMI_DISPLAY_MODE_MAX))
    {
        // cannot select an operator page that is switched off (or invalid)
        returnVal = eFALSE;
    }

    // Check that the required autoscroll is available
    if (autoscrollState)
    {
        #if !defined(SECOND_OPERATOR_PAGE)
            // cannot turn autoscroll on if only one operator page
            returnVal = eFALSE;
        #else

        if (SFD_MULTI_OP.autoscrollEnable != eTRUE)
        {
            // cannot turn autoscroll on if autoscroll not enabled
            returnVal = eFALSE;
        }
        #endif
    }

    if (returnVal)
    {
        #ifdef HMI_SUPPORTS_SERVICEPORT
        if (instance == HMI_LOCAL_INSTANCE)
        {
            #pragma diag_suppress=Pm088
            FrameTableLocal_1.startupFrame = STARTINGFRAME + (operatorPage - 1);
            #pragma diag_default=Pm088
            FrameTableLocal_1.autoscroll   = autoscrollState;
        }
        else if (instance == HMI_REMOTE_INSTANCE)
        {
            #pragma diag_suppress=Pm088
            FrameTableLocal_2.startupFrame = STARTINGFRAME + (operatorPage - 1);
            #pragma diag_default=Pm088
            FrameTableLocal_2.autoscroll   = autoscrollState;
        }
        #else
        if (instance == HMI_LOCAL_INSTANCE)
        {
            #pragma diag_suppress=Pm088
            startupFrame = STARTINGFRAME + (operatorPage - 1);
            #pragma diag_default=Pm088
            autoscroll   = autoscrollState;
        }
        #endif
        else
        {
           returnVal = eFALSE;
        }
    }
    return returnVal;
}

#ifdef HMI_SUPPORTS_EASYSETUP

/*----------------------------------------------------------------------------------------------------------!
 \brief         Gets details of the easy setup menu
 \author        Roger Arnold
 \param         p_lastStage   - the number of the last frame in the easy setup menu
                p_actualStage - the current position in the easy setup menu
 \return        void
 \test          No details available
*/
// no restriction on the optimization of this function
void FrameTableGetEasySetupStages(TUSIGN8 *p_lastStage, TUSIGN8 *p_actualStage)
{
    *p_lastStage = LOCAL_easySetup_lastStage;
    *p_actualStage = LOCAL_easySetup_actualStage;
}

/*----------------------------------------------------------------------------------------------------------!
 \brief         Gets the validity test index for an easy setup frame
 \author        Roger Arnold
 \param         frameNumber - the selected frame in an easy setup menu
                pageNumber  - the selected easy setup menu
 \return        TUSIGN8 the validity test index for the selected easy setup frame
 \test          No details available
*/
// no restriction on the optimization of this function
TUSIGN8 FrameTableGetEasySetupValidityTestIndex(TUSIGN8 frameNumber, TUSIGN8 pageNumber)
{
    TUSIGN8 returnVal = IDF_VALID_never;

    pageNumber --;

    if (pageNumber < sizeof(EasySetupValidityTestListOfTables))
    {
        ESVT_LIST_OF_TABLES_ENTRY tableDetails = EasySetupValidityTestListOfTables[pageNumber];

        if (frameNumber < tableDetails.tableSize)
        {
            returnVal = tableDetails.tableAddress[frameNumber];
        }
    }
    return returnVal;
}

/*----------------------------------------------------------------------------------------------------------!
 \brief         Increments the current position in the easy setup menu
 \author        Roger Arnold
 \param         none
 \return        TBOOL eTRUE - the increment was successful
                     eFALSE - the increment was unsuccessful because current position already at limit
 \test          No details available
*/
// no restriction on the optimization of this function
TBOOL FrameTableIncrementEasySetupStage(void)
{
    TBOOL returnVal = eFALSE;

    if (LOCAL_easySetup_actualStage < LOCAL_easySetup_lastStage)
    {
        LOCAL_easySetup_actualStage ++;
        returnVal = eTRUE;
    }
    return returnVal;
}

#endif

#ifdef AZ200_SPECIAL_FEATURES_HMI
FRAME_FORMAT_TYPE const* FrameTableGetCalFrameAddress(TUSIGN8 CalibrationType)
{
    FRAME_FORMAT_TYPE const* returnVal;

    assert((CalibrationType == CAL_CALIBRATE_OFFSET_ONLY) || (CalibrationType == CAL_CALIBRATE_FACTOR_ONLY) || (CalibrationType == CAL_CALIBRATE_OFFSET_AND_FACTOR));

    switch (CalibrationType)
    {
    case CAL_CALIBRATE_OFFSET_ONLY:         returnVal = &ONE_POINT_CAL_FRAME;                                           break;
    case CAL_CALIBRATE_FACTOR_ONLY:         returnVal = &ONE_POINT_CAL_FRAME;                                           break;
    case CAL_CALIBRATE_OFFSET_AND_FACTOR:   returnVal = &TWO_POINT_CAL_FRAME;                                           break;
    default:                                returnVal = NULL;                                                           break;
    }
    return returnVal;
}
#endif

#ifdef HMI_SUPPORTS_MANUAL_VALVE_CAL
void FrameTableActivateManualValveCal(void)
{
    LOCAL_ManualValveCalEnable = eTRUE;
}

void FrameTableDeactivateManualValveCal(void)
{
    LOCAL_ManualValveCalEnable = eFALSE;
}

TBOOL FrameTableIsManualValveCalActive(void)
{
    return LOCAL_ManualValveCalEnable;
}
#endif

#ifdef HMI_SUPPORTS_CONFIG_CHANGE_COUNTER
void FrameTableDeactivateConfigChangeCounter(void)
{
    LOCAL_ConfigChangeCounter_enable = eFALSE;
    LOCAL_ConfigChangeCounter_ssIdx = 0;
    LOCAL_ConfigChangeCounter_obIdx = 0;
    LOCAL_ConfigChangeCounter_atIdx = 0;
}

void FrameTableActivateConfigChangeCounter(TUSIGN16 ss_Idx, TUSIGN16 ob_Idx, TINT16 at_Idx)
{
    LOCAL_ConfigChangeCounter_enable = eTRUE;
    LOCAL_ConfigChangeCounter_ssIdx = ss_Idx;
    LOCAL_ConfigChangeCounter_obIdx = ob_Idx;
    LOCAL_ConfigChangeCounter_atIdx = at_Idx;
}

TBOOL FrameTableIncrementConfigChangeCounter(void)
{
    TBOOL returnVal = eFALSE;
    if (LOCAL_ConfigChangeCounter_enable)
    {
        TUSIGN16    ConfigChangeCounter;

        T_UNIT const SLOW *pSub = GetSubsystemPtr((T_SUBSYSTEM_IDX)LOCAL_ConfigChangeCounter_ssIdx);
        if (pSub->Get(pSub,LOCAL_ConfigChangeCounter_obIdx,LOCAL_ConfigChangeCounter_atIdx,(void FAST *)&ConfigChangeCounter) == (TUSIGN16)OK)
        {
            ConfigChangeCounter ++;

            if (pSub->Put(pSub,LOCAL_ConfigChangeCounter_obIdx,LOCAL_ConfigChangeCounter_atIdx,(void FAST *)&ConfigChangeCounter) == (TUSIGN16)OK)
            {
                returnVal = eTRUE;
            }
        }
    }
    return returnVal;
}
#endif

#ifdef HMI_SUPPORTS_SEQUENCES
void FrameTableEnableSequence(void)
{
    LOCAL_SequentialMenuEnable = eTRUE;
}

void FrameTableDisableSequence(void)
{
    LOCAL_SequentialMenuEnable = eFALSE;
}

TBOOL FrameTableIsSequenceEnabled(void)
{
    return LOCAL_SequentialMenuEnable;
}

void FrameTableSetSequenceSettings(TUSIGN8 SeqMenuPosnCursor, TUSIGN8 SeqMenuPosnCursorLim, TUSIGN16 SeqMenuTableOffset)
{
    LOCAL_SequentialMenuPosnCursor    = SeqMenuPosnCursor;
    LOCAL_SequentialMenuPosnCursorLim = SeqMenuPosnCursorLim;
    LOCAL_SequentialMenuTableOffset   = SeqMenuTableOffset;
}

TBOOL FrameTableGetSequenceSettings(TUSIGN8* pSequentialMenuPosnCursor, TUSIGN8* pSequentialMenuPosnCursorLim, TUSIGN16* pSequentialMenuTableOffset)
{
    *pSequentialMenuPosnCursor    = LOCAL_SequentialMenuPosnCursor;
    *pSequentialMenuPosnCursorLim = LOCAL_SequentialMenuPosnCursorLim;
    *pSequentialMenuTableOffset   = LOCAL_SequentialMenuTableOffset;
    return LOCAL_SequentialMenuEnable;
}
#endif



void FrameTableAccessMenuPositionDetails(TUSIGN8* pCursor, TUSIGN8* pCursorLim, TBOOL Get)
{
    if (Get)
    {
        *pCursor = LOCAL_menuPosnCursor;
        *pCursorLim = LOCAL_menuPosnCursorLim;
    }
    else
    {
        LOCAL_menuPosnCursor = *pCursor;
        LOCAL_menuPosnCursorLim = *pCursorLim;
    }
}

#ifdef HMI_SUPPORTS_OUTPUT_HOLD_AND_RELEASE
void FrameTableActivateOutputHold(void)
{
    SetOutputHold(1);
}

void FrameTableReleaseOutputHold(void)
{
    SetOutputHold(0);
}

void SetOutputHold(TUSIGN8 HoldValue)
{
    if (LOCAL_OutputHold_enable == eTRUE)
    {
        TUSIGN8 newValue = HoldValue;

        T_UNIT const SLOW *pSub = GetSubsystemPtr((T_SUBSYSTEM_IDX)LOCAL_OutputHoldState_ssIdx);
        pSub->Put(pSub,(TUSIGN16)LOCAL_OutputHoldState_objIdx,(TINT16)LOCAL_OutputHoldState_attIdx,(void FAST *)&newValue);
    }
}

void FrameTableSetOutputHoldSettings(TBOOL enable, TUSIGN8 ssIdx, TUSIGN8 objIdx, TUSIGN8 attIdx)
{
    LOCAL_OutputHold_enable = enable;

    LOCAL_OutputHoldState_ssIdx = ssIdx;
    LOCAL_OutputHoldState_objIdx = objIdx;
    LOCAL_OutputHoldState_attIdx = attIdx;
}

TBOOL FrameTableGetOutputHoldSettings(TUSIGN8 *pssIdx, TUSIGN8 *pobjIdx, TUSIGN8 *pattIdx)
{
    *pssIdx = LOCAL_OutputHoldState_ssIdx;
    *pobjIdx = LOCAL_OutputHoldState_objIdx;
    *pattIdx = LOCAL_OutputHoldState_attIdx;

    return LOCAL_OutputHold_enable;
}

TBOOL FrameTable_IsOutputHeld(void)
{
    TBOOL returnVal = eFALSE;

    if (LOCAL_OutputHold_enable == eTRUE)
    {
        TUSIGN8 holdValue;
        T_UNIT const SLOW *pSub = GetSubsystemPtr((T_SUBSYSTEM_IDX)LOCAL_OutputHoldState_ssIdx);
        pSub->Get(pSub,(TUSIGN16)LOCAL_OutputHoldState_objIdx,(TINT16)LOCAL_OutputHoldState_attIdx,(void FAST *)&holdValue);

        if (holdValue)
        {
            returnVal = eTRUE;
        }
    }
    return returnVal;
}
#endif

#ifdef HMI_SUPPORTS_AUTO_ADJUST
void FrameTableSetAutoAdjustAbortSettings(TBOOL enable, TUSIGN8 ssIdx, TUSIGN8 objIdx, TUSIGN8 attIdx)
{
    LOCAL_AutoAdjustAbort_enable = enable;

    LOCAL_AutoAdjustAbort_ssIdx = ssIdx;
    LOCAL_AutoAdjustAbort_objIdx = objIdx;
    LOCAL_AutoAdjustAbort_attIdx = attIdx;
}

TBOOL FrameTableGetAutoAdjustAbortSettings(TUSIGN8 *pssIdx, TUSIGN8 *pobjIdx, TUSIGN8 *pattIdx)
{
    if ((pssIdx) && (pobjIdx) && (pattIdx))
    {
        *pssIdx = LOCAL_AutoAdjustAbort_ssIdx;
        *pobjIdx = LOCAL_AutoAdjustAbort_objIdx;
        *pattIdx = LOCAL_AutoAdjustAbort_attIdx;
    }
    return LOCAL_AutoAdjustAbort_enable;
}
#endif

#ifdef HMI_SUPPORTS_MANUAL_ADJUST_MODIFIER
void FrameTableSetManualAdjustModifier(TUSIGN8 Modifier)
{
    // ManualAdjustModifier
    // --------------------
    //  0 = No modifier (bargraph displayed)
    //  1 = Manual Valve control
    //  2 = Manual Relay Control
    //  3 = Manual Digital O/P Control

    if (Modifier > 3)
    {
        Modifier = 0;
    }

    LOCAL_ManualAdjustModifier = Modifier;
}

TUSIGN8 FrameTableGetManualAdjustModifier(void)
{
    return LOCAL_ManualAdjustModifier;
}
#endif

#ifdef HMI_SUPPORTS_AUTO_CALIBRATION
void FrameTableAllowNavigationFromAutoCal(TBOOL allow)
{
    LOCAL_NavigationFromAutoCalAllowed = allow;
}

TBOOL FrameTableIsNavigationFromAutoCalAllowed(void)
{
    return LOCAL_NavigationFromAutoCalAllowed;
}

void  FrameTableRenameAutocal(TBOOL renameAutocal)
{
    LOCAL_AutoCalRenamed = renameAutocal;
}

TBOOL FrameTableIsAutoCalRenamed(void)
{
    return LOCAL_AutoCalRenamed;
}

void  FrameTableRemoveSettling(TBOOL removeSettling)
{
    LOCAL_AutoCalSettlingRemoved = removeSettling;
}

TBOOL FrameTableIsSettlingRemoved(void)
{
    return LOCAL_AutoCalSettlingRemoved;
}

#endif

#ifdef HMI_SUPPORTS_MANUAL_CALIBRATION
void FrameTableEnableSampleCollection(TBOOL enable)
{
    LOCAL_SampleCollectionEnabled = enable;
}

TBOOL FrameTableIsSampleCollectionEnabled(void)
{
    return LOCAL_SampleCollectionEnabled;
}
#endif


#ifdef HMI_SUPPORTS_SECONDARY_IDENTIFIER
void FrameTableSetSecondaryIdentifier(TBOOL enable, TUSIGN8* pSecondaryIdentifierText)
{
    LOCAL_SecondaryIdentifier_Enable = enable;
    if (enable)
    {
        strncpy((char *)LOCAL_SecondaryIdentifier_Text, (const char *)pSecondaryIdentifierText, SECONDARY_IDENTIFIER_LEN);
    }
}

TBOOL FrameTableGetSecondaryIdentifier(TUSIGN8* pSecondaryIdentifierText)
{
    strncpy((char *)pSecondaryIdentifierText, (const char *)LOCAL_SecondaryIdentifier_Text, SECONDARY_IDENTIFIER_LEN);
    return LOCAL_SecondaryIdentifier_Enable;
}
#endif

void FrameTableRestrictNumericCharacterSet(TBOOL AllowSpace, TUSIGN8 MinValid, TUSIGN8 MaxValid)
{
    if ((MinValid > 9) || (MinValid > MaxValid))
    {
        MinValid = 0;
    }
    if ((MaxValid > 9) || (MinValid > MaxValid))
    {
        MaxValid = 9;
    }
    LOCAL_NumericCharacterSetAllowSpace = AllowSpace;
    LOCAL_NumericCharacterSetMinValid = MinValid;
    LOCAL_NumericCharacterSetMaxValid = MaxValid;
}

void FrameTableGetNumericCharacterSetRestrictions(TBOOL* pAllowSpace, TUSIGN8* pMinValid, TUSIGN8* pMaxValid)
{
    *pAllowSpace = LOCAL_NumericCharacterSetAllowSpace;
    *pMinValid   = LOCAL_NumericCharacterSetMinValid;
    *pMaxValid   = LOCAL_NumericCharacterSetMaxValid;
}


#ifdef HMI_SUPPORTS_TIME_DATE_PARAM_FRAMES
void FrameTableSetTimeDurationLimit(TUSIGN8 durationLimit)
{
    LOCAL_TimeDurationLimit = (TUSIGN32)durationLimit * 3600;
}

TUSIGN32 FrameTableGetTimeDurationLimit(void)
{
    return LOCAL_TimeDurationLimit;
}
#endif

#ifdef ENUM_ACCELERATOR
    #define ENUM_ACCELERATOR_BP_2      10
    #define ENUM_ACCELERATOR_BP_1       5
    #define ENUM_ACCELERATOR_RATE_0     1
    #define ENUM_ACCELERATOR_RATE_1     2

    #ifndef COMMON_TOP_WORKS_NEW_FEATURES
    #define ENUM_ACCELERATOR_RATE_2      (ITEMS_PER_MENU - 1)  // ENUM_ACCELERATOR_RATE_2 is not defined in COMMON_TOP_WORKS_NEW_FEATURES versions  - rate is calculated based upon SFD_SIMPLE.MenuFormat
    #endif

void FrameTableUpdateEnumAccellerator(TUSIGN8 keystate)
{
    static TUSIGN8 prvKeystate = KEYSTATE_NONE;

    #ifdef HMI_SUPPORTS_SERVICEPORT
    static TUSIGN8 prvKeystate_remote = KEYSTATE_NONE;

    if (pFrameTableLocal == &FrameTableLocal_2)
    {
        if ((keystate == KEYSTATE_NONE)
         || (keystate != prvKeystate_remote))
        {
            FrameTableLocal_2.EnumAccellerator = 0;
        }
        else
        {
            if ((keystate == KEYSTATE_UP)
             || (keystate == KEYSTATE_DOWN))
            {
                FrameTableLocal_2.EnumAccellerator ++;
                if (FrameTableLocal_2.EnumAccellerator > ENUM_ACCELERATOR_BP_2)
                {
                    FrameTableLocal_2.EnumAccellerator = ENUM_ACCELERATOR_BP_2;
                }
            }
        }

        prvKeystate_remote = keystate;
    }
    else
    #endif
    {
        if ((keystate == KEYSTATE_NONE)
         || (keystate != prvKeystate))
        {
            LOCAL_EnumAccellerator = 0;
        }
        else
        {
            if ((keystate == KEYSTATE_UP)
             || (keystate == KEYSTATE_DOWN))
            {
                LOCAL_EnumAccellerator ++;
                if (LOCAL_EnumAccellerator > ENUM_ACCELERATOR_BP_2)
                {
                    LOCAL_EnumAccellerator = ENUM_ACCELERATOR_BP_2;
                }
            }
        }
        prvKeystate = keystate;
    }
}

TUSIGN8 FrameTableGetEnumUpdateAmount(void)
{
    TUSIGN8 EnumUpdateAmount = 0;
    if (LOCAL_EnumAccellerator >= ENUM_ACCELERATOR_BP_2)
    {
        #ifdef COMMON_TOP_WORKS_NEW_FEATURES
            switch (SFD_SIMPLE_CTW.MenuFormat)
            {
            case MENU_FORMAT_3_LINES:   EnumUpdateAmount = 2;   break;
            case MENU_FORMAT_4_LINES:   EnumUpdateAmount = 3;   break;
            case MENU_FORMAT_5_LINES:   EnumUpdateAmount = 4;   break;
            case MENU_FORMAT_6_LINES:   EnumUpdateAmount = 5;   break;
            default:                    EnumUpdateAmount = 3;   break;
            }
        #else
            EnumUpdateAmount = ENUM_ACCELERATOR_RATE_2;
        #endif

        #ifdef HMI_SUPPORTS_SECONDARY_IDENTIFIER
        TUSIGN8 SecondaryIdentifierText[SECONDARY_IDENTIFIER_LEN];
        if ((FrameTableGetSecondaryIdentifier(SecondaryIdentifierText)) && (EnumUpdateAmount > 4))
        {
            EnumUpdateAmount = 4;
        }
        #endif
    }
    else if (LOCAL_EnumAccellerator >= ENUM_ACCELERATOR_BP_1)
    {
        EnumUpdateAmount = ENUM_ACCELERATOR_RATE_1;
    }
    else
    {
        EnumUpdateAmount = ENUM_ACCELERATOR_RATE_0;
    }
    return EnumUpdateAmount;
}

#endif // #ifdef ENUM_ACCELERATOR

#ifdef STRING_ACCELERATOR
    #define STRING_ACCELERATOR_BP_2   10
    #define STRING_ACCELERATOR_BP_1   5
    #define STRING_ACCELERATOR_RATE_0 1
    #define STRING_ACCELERATOR_RATE_1 2
    #define STRING_ACCELERATOR_RATE_2 5

void FrameTableUpdateStringAccellerator(TUSIGN8 keystate)
{
    static TUSIGN8 prvKeystate = KEYSTATE_NONE;

    #ifdef HMI_SUPPORTS_SERVICEPORT
    static TUSIGN8 prvKeystate_remote = KEYSTATE_NONE;

    if (pFrameTableLocal == &FrameTableLocal_2)
    {
        if ((keystate == KEYSTATE_NONE)
         || (keystate != prvKeystate_remote))
        {
            FrameTableLocal_2.StringAccellerator = 0;
        }
        else
        {
            if ((keystate == KEYSTATE_UP)
             || (keystate == KEYSTATE_DOWN))
            {
                FrameTableLocal_2.StringAccellerator ++;
                if (FrameTableLocal_2.StringAccellerator > STRING_ACCELERATOR_BP_2)
                {
                    FrameTableLocal_2.StringAccellerator = STRING_ACCELERATOR_BP_2;
                }
            }
        }

        prvKeystate_remote = keystate;
    }
    else
    #endif
    {
        if ((keystate == KEYSTATE_NONE)
         || (keystate != prvKeystate))
        {
            LOCAL_StringAccellerator = 0;
        }
        else
        {
            if ((keystate == KEYSTATE_UP)
             || (keystate == KEYSTATE_DOWN))
            {
                LOCAL_StringAccellerator ++;
                if (LOCAL_StringAccellerator > STRING_ACCELERATOR_BP_2)
                {
                    LOCAL_StringAccellerator = STRING_ACCELERATOR_BP_2;
                }
            }
        }
        prvKeystate = keystate;
    }
}

TUSIGN8 FrameTableGetStringUpdateAmount(void)
{
    TUSIGN8 StringUpdateAmount = 0;
    if (LOCAL_StringAccellerator >= STRING_ACCELERATOR_BP_2)
    {
        StringUpdateAmount = STRING_ACCELERATOR_RATE_2;
    }
    else if (LOCAL_StringAccellerator >= STRING_ACCELERATOR_BP_1)
    {
        StringUpdateAmount = STRING_ACCELERATOR_RATE_1;
    }
    else
    {
        StringUpdateAmount = STRING_ACCELERATOR_RATE_0;
    }
    return StringUpdateAmount;
}

#endif // #ifdef STRING_ACCELERATOR

#ifdef IPADDR_ACCELERATOR

    #define IPADDR_ACCELERATOR_BP_2   20
    #define IPADDR_ACCELERATOR_BP_1   10
    #define IPADDR_ACCELERATOR_RATE_0 1
    #define IPADDR_ACCELERATOR_RATE_1 10
    #define IPADDR_ACCELERATOR_RATE_2 10

void FrameTableUpdateIPAddressAccellerator(TUSIGN8 keystate)
{
    static TUSIGN8 prvKeystate = KEYSTATE_NONE;

    #ifdef HMI_SUPPORTS_SERVICEPORT
    static TUSIGN8 prvKeystate_remote = KEYSTATE_NONE;

    if (pFrameTableLocal == &FrameTableLocal_2)
    {
        if ((keystate == KEYSTATE_NONE)
         || (keystate != prvKeystate_remote))
        {
            FrameTableLocal_2.IPAddrAccellerator = 0;
        }
        else
        {
            if ((keystate == KEYSTATE_UP)
             || (keystate == KEYSTATE_DOWN))
            {
                FrameTableLocal_2.IPAddrAccellerator ++;
                if (FrameTableLocal_2.IPAddrAccellerator > IPADDR_ACCELERATOR_BP_2)
                {
                    FrameTableLocal_2.IPAddrAccellerator = IPADDR_ACCELERATOR_BP_2;
                }
            }
        }

        prvKeystate_remote = keystate;
    }
    else
    #endif
    {
        if ((keystate == KEYSTATE_NONE)
         || (keystate != prvKeystate))
        {
            LOCAL_IPAddrAccellerator = 0;
        }
        else
        {
            if ((keystate == KEYSTATE_UP)
             || (keystate == KEYSTATE_DOWN))
            {
                LOCAL_IPAddrAccellerator ++;
                if (LOCAL_IPAddrAccellerator > IPADDR_ACCELERATOR_BP_2)
                {
                    LOCAL_IPAddrAccellerator = IPADDR_ACCELERATOR_BP_2;
                }
            }
        }
        prvKeystate = keystate;
    }
}

TUSIGN8 FrameTableGetIPAddressUpdateAmount(void)
{
    TUSIGN8 IPAddrUpdateAmount = 0;
    if (LOCAL_IPAddrAccellerator >= IPADDR_ACCELERATOR_BP_2)
    {
        IPAddrUpdateAmount = IPADDR_ACCELERATOR_RATE_2;
    }
    else if (LOCAL_IPAddrAccellerator >= IPADDR_ACCELERATOR_BP_1)
    {
        IPAddrUpdateAmount = IPADDR_ACCELERATOR_RATE_1;
    }
    else
    {
        IPAddrUpdateAmount = IPADDR_ACCELERATOR_RATE_0;
    }
    return IPAddrUpdateAmount;
}

#endif  // #ifdef IPADDR_ACCELERATOR

#ifdef DATE_TIME_ACCELERATOR
    #define DATE_TIME_ACCELERATOR_BP_2    20
    #define DATE_TIME_ACCELERATOR_BP_1    10
    #define DATE_TIME_ACCELERATOR_RATE_0  1
    #define DATE_TIME_ACCELERATOR_RATE_1  2
    #define DATE_TIME_ACCELERATOR_RATE_2a 4
    #define DATE_TIME_ACCELERATOR_RATE_2b 10

void FrameTableUpdateDateTimeAccellerator(TUSIGN8 keystate)
{
    static TUSIGN8 prvKeystate = KEYSTATE_NONE;

    #ifdef HMI_SUPPORTS_SERVICEPORT
    static TUSIGN8 prvKeystate_remote = KEYSTATE_NONE;

    if (pFrameTableLocal == &FrameTableLocal_2)
    {
        if ((keystate == KEYSTATE_NONE)
         || (keystate != prvKeystate_remote))
        {
            FrameTableLocal_2.DateTimeAccellerator = 0;
        }
        else
        {
            if ((keystate == KEYSTATE_UP)
             || (keystate == KEYSTATE_DOWN))
            {
                FrameTableLocal_2.DateTimeAccellerator ++;
                if (FrameTableLocal_2.DateTimeAccellerator > DATE_TIME_ACCELERATOR_BP_2)
                {
                    FrameTableLocal_2.DateTimeAccellerator = DATE_TIME_ACCELERATOR_BP_2;
                }
            }
        }

        prvKeystate_remote = keystate;
    }
    else
    #endif
    {
        if ((keystate == KEYSTATE_NONE)
         || (keystate != prvKeystate))
        {
            LOCAL_DateTimeAccellerator = 0;
        }
        else
        {
            if ((keystate == KEYSTATE_UP)
             || (keystate == KEYSTATE_DOWN))
            {
                LOCAL_DateTimeAccellerator ++;
                if (LOCAL_DateTimeAccellerator > DATE_TIME_ACCELERATOR_BP_2)
                {
                    LOCAL_DateTimeAccellerator = DATE_TIME_ACCELERATOR_BP_2;
                }
            }
        }
        prvKeystate = keystate;
    }
}

TUSIGN8 FrameTableGetDateTimeUpdateAmount(TUSIGN8 field, TUSIGN8 hoursMax)
{
    TUSIGN8 DateTimeUpdateAmount = 0;
    if (LOCAL_DateTimeAccellerator >= DATE_TIME_ACCELERATOR_BP_2)
    {
        DateTimeUpdateAmount = DATE_TIME_ACCELERATOR_RATE_2a;
    }
    else if (LOCAL_DateTimeAccellerator >= DATE_TIME_ACCELERATOR_BP_1)
    {
        DateTimeUpdateAmount = DATE_TIME_ACCELERATOR_RATE_1;
    }
    else
    {
        DateTimeUpdateAmount = DATE_TIME_ACCELERATOR_RATE_0;
    }

    switch (field)
    {
    case 1: /* Hours   */
        if (hoursMax <= 10)
        {
            if (DateTimeUpdateAmount > DATE_TIME_ACCELERATOR_RATE_0)
            {
                DateTimeUpdateAmount = DATE_TIME_ACCELERATOR_RATE_0;
            }
        }
        else if (hoursMax <= 25)
        {
            if (DateTimeUpdateAmount > DATE_TIME_ACCELERATOR_RATE_1)
            {
                DateTimeUpdateAmount = DATE_TIME_ACCELERATOR_RATE_1;
            }
        }
        else
        {
            if ((hoursMax > 100) && (DateTimeUpdateAmount == DATE_TIME_ACCELERATOR_RATE_2a))
            {
                DateTimeUpdateAmount = DATE_TIME_ACCELERATOR_RATE_2b;
            }
        }
        break;

    case 2: /* Minutes */
    case 3: /* Seconds */
        asm("nop");
        break;

    case 4: /* Date    */
    case 5: /* Month   */
    case 6: /* Year    */
        DateTimeUpdateAmount = DATE_TIME_ACCELERATOR_RATE_0;
        break;

    default:
        DateTimeUpdateAmount = 0;
        break;
    }

    return DateTimeUpdateAmount;
}
#endif  //#ifdef DATE_TIME_ACCELERATOR


#ifdef MANUAL_ADJUST_ACCELERATOR

    #define MANADJ_ACCELERATOR_BP_4   40
    #define MANADJ_ACCELERATOR_BP_3   30
    #define MANADJ_ACCELERATOR_BP_2   20
    #define MANADJ_ACCELERATOR_BP_1   10
    #define MANADJ_ACCELERATOR_RATE_0 1
    #define MANADJ_ACCELERATOR_RATE_1 10
    #define MANADJ_ACCELERATOR_RATE_2 100
    #define MANADJ_ACCELERATOR_RATE_3 1000
    #define MANADJ_ACCELERATOR_RATE_4 10000

void FrameTableUpdateManAdjustAccellerator(TUSIGN8 keystate)
{
    static TUSIGN8 prvKeystate = KEYSTATE_NONE;

    #ifdef HMI_SUPPORTS_SERVICEPORT
    static TUSIGN8 prvKeystate_remote = KEYSTATE_NONE;

    if (pFrameTableLocal == &FrameTableLocal_2)
    {
        if ((keystate == KEYSTATE_NONE)
         || (keystate != prvKeystate_remote))
        {
            FrameTableLocal_2.ManAdjAccellerator = 0;
        }
        else
        {
            if ((keystate == KEYSTATE_UP)
             || (keystate == KEYSTATE_DOWN))
            {
                FrameTableLocal_2.ManAdjAccellerator ++;

                TUSIGN8 MaxBreakpoint;

                switch (FrameTableLocal_2.ManAdjMaxAccelleratorStage)
                {
                case 4:     MaxBreakpoint = MANADJ_ACCELERATOR_BP_4;    break;
                case 3:     MaxBreakpoint = MANADJ_ACCELERATOR_BP_3;    break;
                case 2:     MaxBreakpoint = MANADJ_ACCELERATOR_BP_2;    break;
                case 1:     MaxBreakpoint = MANADJ_ACCELERATOR_BP_1;    break;
                default:    MaxBreakpoint = 0;                          break;
                }

                if (FrameTableLocal_2.ManAdjAccellerator > MaxBreakpoint)
                {
                    FrameTableLocal_2.ManAdjAccellerator = MaxBreakpoint;
                }
            }
        }

        prvKeystate_remote = keystate;
    }
    else
    #endif
    {
        if ((keystate == KEYSTATE_NONE)
         || (keystate != prvKeystate))
        {
            LOCAL_ManAdjAccellerator = 0;
        }
        else
        {
            if ((keystate == KEYSTATE_UP)
             || (keystate == KEYSTATE_DOWN))
            {
                LOCAL_ManAdjAccellerator ++;

                TUSIGN8 MaxBreakpoint;

                switch (LOCAL_ManAdjMaxAccelleratorStage)
                {
                case 4:     MaxBreakpoint = MANADJ_ACCELERATOR_BP_4;    break;
                case 3:     MaxBreakpoint = MANADJ_ACCELERATOR_BP_3;    break;
                case 2:     MaxBreakpoint = MANADJ_ACCELERATOR_BP_2;    break;
                case 1:     MaxBreakpoint = MANADJ_ACCELERATOR_BP_1;    break;
                default:    MaxBreakpoint = 0;                          break;
                }

                if (LOCAL_ManAdjAccellerator > MaxBreakpoint)
                {
                    LOCAL_ManAdjAccellerator = MaxBreakpoint;
                }
            }
        }
        prvKeystate = keystate;
    }
}

TUSIGN16 FrameTableGetManAdjustUpdateAmount(void)
{
    TUSIGN16 ManAdjUpdateAmount = 0;
    if (LOCAL_ManAdjAccellerator >= MANADJ_ACCELERATOR_BP_4)
    {
        ManAdjUpdateAmount = MANADJ_ACCELERATOR_RATE_4;
    }
    else if (LOCAL_ManAdjAccellerator >= MANADJ_ACCELERATOR_BP_3)
    {
        ManAdjUpdateAmount = MANADJ_ACCELERATOR_RATE_3;
    }
    else if (LOCAL_ManAdjAccellerator >= MANADJ_ACCELERATOR_BP_2)
    {
        ManAdjUpdateAmount = MANADJ_ACCELERATOR_RATE_2;
    }
    else if (LOCAL_ManAdjAccellerator >= MANADJ_ACCELERATOR_BP_1)
    {
        ManAdjUpdateAmount = MANADJ_ACCELERATOR_RATE_1;
    }
    else
    {
        ManAdjUpdateAmount = MANADJ_ACCELERATOR_RATE_0;
    }
    return ManAdjUpdateAmount;
}

void FrameTableSetSpecialManualAdjust(TUSIGN8 maxAccelerationRate, TUSIGN8 DisplayBargraphValueCharacters, TUSIGN8 DisplayBargraphValuePrecision)
{
    if (maxAccelerationRate > 4)
    {
        maxAccelerationRate = 4;
    }

    if (DisplayBargraphValueCharacters > 7)
    {
        DisplayBargraphValueCharacters = 7;
    }

    if (DisplayBargraphValueCharacters <= 2)
    {
        DisplayBargraphValuePrecision = 0;
    }
    else
    {
        if (DisplayBargraphValuePrecision > (DisplayBargraphValueCharacters - 2))
        {
            DisplayBargraphValuePrecision = (DisplayBargraphValueCharacters - 2);
        }
    }

    #ifdef HMI_SUPPORTS_SERVICEPORT
    if (pFrameTableLocal == &FrameTableLocal_2)
    {
        FrameTableLocal_2.ManAdjMaxAccelleratorStage = maxAccelerationRate;
        FrameTableLocal_2.ManAdjBargraphValueCharacters = DisplayBargraphValueCharacters;
        FrameTableLocal_2.ManAdjBargraphValuePrecision  = DisplayBargraphValuePrecision;
    }
    else
    #endif
    {
        LOCAL_ManAdjMaxAccelleratorStage = maxAccelerationRate;
        LOCAL_ManAdjBargraphValueCharacters = DisplayBargraphValueCharacters;
        LOCAL_ManAdjBargraphValuePrecision  = DisplayBargraphValuePrecision;
    }
}

TUSIGN8 FrameTableGetSpecialManualAdjustDisplayBargraphValueCharacters(void)
{
    return LOCAL_ManAdjBargraphValueCharacters;
}

TUSIGN8 FrameTableGetSpecialManualAdjustDisplayBargraphValuePrecision(void)
{
    return LOCAL_ManAdjBargraphValuePrecision;
}

#endif  // #ifdef MANUAL_ADJUST_ACCELERATOR

#ifndef DISABLE_BACK_MOVE_SELECT
TBOOL FrameTableIsBackMoveSelectAvailable(const FRAME_FORMAT_TYPE *pCallingFrame)
{
    TBOOL ReturnVal = eFALSE;

    TBOOL sequenceEnabled = eFALSE;
    TBOOL InEasySetupMenu = eFALSE;

    #ifdef HMI_SUPPORTS_SEQUENCES
    sequenceEnabled = LOCAL_SequentialMenuEnable;
    #endif

    #ifdef HMI_SUPPORTS_EASYSETUP
    InEasySetupMenu = pCallingFrame->frameDefinition.enumParamFrame.easySetupFlag != 0 ? eTRUE : eFALSE ;
    #endif

    if ((!sequenceEnabled) && (!InEasySetupMenu))
    {
        // calculate number of frames immediately below this menu that could be accessed via BACK_MOVE_SELECT
        const FRAME_FORMAT_TYPE *pParentMenu = LOCAL_mostRecentStandardMenu;

        TUSIGN16 FirstItem = ((TUSIGN16)pParentMenu->frameDefinition.menuFrame.firstItem_MSByte << 8) + (TUSIGN16)pParentMenu->frameDefinition.menuFrame.firstItem_LSByte;
        TUSIGN16 LastItem  = ((TUSIGN16)pParentMenu->frameDefinition.menuFrame.lastItem_MSByte << 8) + (TUSIGN16)pParentMenu->frameDefinition.menuFrame.lastItem_LSByte;
        TUSIGN8 counterCursorLimit = (TUSIGN8)(LastItem - FirstItem);
        TUSIGN8 counterCursor = 0;

        TUSIGN8 AccessibleFrames = 0;

        const FRAME_FORMAT_TYPE *pChild = pParentMenu->frameDefinition.menuFrame.pNextFrame;
        do
        {
            TUSIGN8 childFrameType = pChild->frameType;

            if ((childFrameType == FRAME_TYPE_NUMERICAL_PARAM)
             || (childFrameType == FRAME_TYPE_NUMERICAL_PARAM_NO_EDIT)
             || (childFrameType == FRAME_TYPE_ENUMERATED_PARAM)
             || (childFrameType == FRAME_TYPE_ENUMERATED_PARAM_NO_EDIT)
             || (childFrameType == FRAME_TYPE_ENUMERATED_PARAM_OVERRIDE_WP)
             || (childFrameType == FRAME_TYPE_STRING_PARAM)
             || (childFrameType == FRAME_TYPE_STRING_PARAM_NO_EDIT)
             || (childFrameType == FRAME_TYPE_STRING_PARAM_PACKED)
             || (childFrameType == FRAME_TYPE_STRING_PARAM_PACKED_NO_EDIT)
             || (childFrameType == FRAME_TYPE_TIME_AND_DATE_PARAM)
             || (childFrameType == FRAME_TYPE_TIME_AND_DATE_PARAM_NO_EDIT)
             || (childFrameType == FRAME_TYPE_BIT_ENUMERATED_PARAM)
             || (childFrameType == FRAME_TYPE_BIT_ENUMERATED_PARAM_NO_EDIT)
             || (childFrameType == FRAME_TYPE_INTEGER_PARAM)
             || (childFrameType == FRAME_TYPE_INTEGER_PARAM_NO_EDIT)
             #ifdef HMI_SUPPORTS_GRAPH_PARAM_FRAMES
             || (childFrameType == FRAME_TYPE_GRAPH_PARAM_FRAME_1_NO_EDIT)
             || (childFrameType == FRAME_TYPE_GRAPH_PARAM_FRAME_2_NO_EDIT)
             #endif
             || (childFrameType == FRAME_TYPE_IP_ADDRESS)
             || (childFrameType == FRAME_TYPE_IP_ADDRESS_NO_EDIT))
            {
                // check that the child frame is available...
                // ...1 Get pointer to the menu item associated with this child frame
                MENU_ITEM_TYPE const *pMenuItem = FrameTableGetMenuItem((TUSIGN16)(FirstItem + counterCursor));
                TBOOL ChildValid;

                if (pMenuItem == NULL)
                {
                    // Menu Item not found - therefore child not valid
                    ChildValid = eFALSE;
                }
                else
                {
                    // Menu Item found - Perform the validity test on this menu Item
                    ChildValid = ValidityTestCheck((TUSIGN16)pMenuItem->validTest
#ifdef VALIDITY_TEST_CALLER
						, SIGNALS_TEST_NOT_APPLICABLE
#endif
					) ? eTRUE : eFALSE;
                }

                if (ChildValid)
                {
                    AccessibleFrames ++;
                }
            }

            #pragma diag_suppress=Pm088
            pChild ++;
            #pragma diag_default=Pm088
            counterCursor ++;
        }
        while ((counterCursor <= counterCursorLimit) && (AccessibleFrames < 2));

        if (AccessibleFrames >= 2)
        {
            ReturnVal = eTRUE;
        }
    }
    return ReturnVal;
}
#endif



#ifdef EDP300_SPECIAL_FEATURES_HMI
#pragma diag_suppress=Pm022
__root const FRAME_FORMAT_TYPE EDP300ModeFrame=
{
FRAME_TYPE_MENU,
#ifdef HMI_USES_SPECIAL_OP_CODES
IDF_SPECIAL_NONE,
IDF_SPECIAL_NONE,
IDF_SPECIAL_NONE,
#endif
//lint -e{708}
NULL,               // *pNextFrame
20,                 // titleBar_attribidx
0,                  // unused_1
0,                  // firstItem_LSByte
0,                  // firstItem_MSByte
0,                  // lastItem_LSByte
0,                  // lastItem_MSByte
0,0,0,0,            // unused_2, unused_3, unused_4, unused_5
7,                  // specialMenuFlag
#ifdef HMI_SUPPORTS_EASYSETUP
0,                  // unused_spare
#endif
};

__root const FRAME_FORMAT_TYPE EDP300QuickAdjustFrame=
{
FRAME_TYPE_MENU,
#ifdef HMI_USES_SPECIAL_OP_CODES
IDF_SPECIAL_NONE,
IDF_SPECIAL_NONE,
IDF_SPECIAL_NONE,
#endif
//lint -e{708}
NULL,               // *pNextFrame
20,                 // titleBar_attribidx
0,                  // unused_1
0,                  // firstItem_LSByte
0,                  // firstItem_MSByte
0,                  // lastItem_LSByte
0,                  // lastItem_MSByte
0,0,0,0,            // unused_2, unused_3, unused_4, unused_5
8,                  // specialMenuFlag
#ifdef HMI_SUPPORTS_EASYSETUP
0,                  // unused_spare
#endif
};
#pragma diag_default=Pm022

FRAME_FORMAT_TYPE const *FrameTableGetEDP300ModeFrame(void)
{
    return &EDP300ModeFrame;
}

FRAME_FORMAT_TYPE const *FrameTableGetEDP300QuickAdjustFrame(void)
{
    return &EDP300QuickAdjustFrame;
}

void FrameTableResetAutoAdjustTimer(void)
{
    EDP300ModeResetAutoAdjustStartDelay();
}

TBOOL FrameTableUpdateAutoAdjustTimer(void)
{
    return EDP300ModeUpdateAutoAdjustStartDelay((TUSIGN16)(3 * HMI_UPDATE_RATE_MILLISEC));
}

TBOOL FrameTableIsAutoAdjustTimerRunning(void)
{
    TUSIGN16 mS;

    return EDP300ModeIsAutoAdjustStartDelayActive(&mS);
}

TUSIGN8 FrameTableAutoAdjustTimeRemaining(void)
{
    TUSIGN16 mS;

    (void)EDP300ModeIsAutoAdjustStartDelayActive(&mS);
    return (TUSIGN8)((mS+500)/1000);
}

TBOOL FrameTableGetAdaptionCheck(void)
{
    return EDP300ModeGetAdaption();
}

TBOOL FrameTableSetAdaptionCheck(void)
{
    return EDP300ModeSetAdaption();
}

TBOOL FrameTableGetControlCheck(void)
{
    return EDP300ModeGetControl();
}

TBOOL FrameTableSetControlCheck(void)
{
    return EDP300ModeSetControl();
}

TBOOL FrameTableGetManualSPCheck(void)
{
    return EDP300ModeGetManualSP();
}

TBOOL FrameTableSetManualSPCheck(void)
{
    return EDP300ModeSetManualSP();
}

TBOOL FrameTableGetManualSensorCheck(void)
{
    return EDP300ModeGetManualSensor();
}

TBOOL FrameTableIsActuatorRotary(void)
{
    return EDP300ModeIsActuatorRotary();
}

TBOOL FrameTableModeIsExhaustPosition0(void)
{
    return EDP300ModeIsExhaustPosition0();
}

TBOOL FrameTableSetManualSensorCheck(void)
{
    return EDP300ModeSetManualSensor();
}

TUSIGN8 FrameTableGetAutoAdjustScope(void)
{
    return EDP300ModeGetAutoAdjustScope();
}

TUSIGN8 FrameTableGetAutoAdjustStatus(void)
{
    return EDP300ModeGetAutoAdjustStatus();
}

TUSIGN8 FrameTableGetAutoAdjustPercentComplete(void)
{
    TUSIGN8 percentComplete = EDP300ModeGetAutoAdjustPercentComplete();

    if (percentComplete > 100)
    {
        percentComplete = 100;
    }
    return percentComplete;
}

TUSIGN8 FrameTableGetAutoAdjustErrorReason(void)
{
    return EDP300ModeGetAutoAdjustErrorReason();
}

void FrameTableAbortAutoAdj(void)
{
    EDP300ModeAbortAutoAdj();
}

void FrameTableFinishAutoAdj(void)
{
    EDP300ModeFinishAutoAdj();
}

void FrameTableStartAdjust(TBOOL Rotary)
{
    if (Rotary)
    {
        EDP300ModeStartAutoAdj_Rotary();
    }
    else
    {
        EDP300ModeStartAutoAdj_Linear();
    }
}

TBOOL FrameTableIfAutoAdjMarker(TUSIGN8 SSIdx, TUSIGN8 ObIdx, TUSIGN8 AtIdx)
{
    return EDP300ModeIfAutoAdjMarker(SSIdx, ObIdx, AtIdx);
}

void FrameTableGetEDP300Mode(TBOOL* pControlCheck,TBOOL* pManSPCheck,TBOOL* pManSenCheck)
{
    TBOOL ControlCheck, ManSPCheck, ManSenCheck;

    EDP300ModeGetMode(&ControlCheck, &ManSPCheck, &ManSenCheck);

    *pControlCheck = ControlCheck;
    *pManSPCheck   = ManSPCheck;
    *pManSenCheck  = ManSenCheck;
}

TBOOL FrameTableIsAccessToModePermitted(void)
{
    return EDP300ModeIsAccessToModePermitted();
}

TBOOL FrameTableIsWriteProtected(ATTRIB_IDENTIFIER_TYPE Data)
{
    return EDP300ModeIsWriteProtected(Data.ssIdx, Data.objIdx, Data.attribIdx);
}

TBOOL FrameTableIsAutoAdjustStartAllowed(void)
{
    return EDP300ModeIsAutoAdjustStartAllowed();
}

#endif // #ifdef EDP300_SPECIAL_FEATURES_HMI

TBOOL FrameTableIsEditDeniedBySpecialOp(void)
{
    return LOCAL_SpecialOpDenyEdit;
}

void FrameTableSpecialOpDenyEdit(void)
{
    LOCAL_SpecialOpDenyEdit = eTRUE;
}

TUSIGN8 FrameTableGetParameterDumpFont(void)
{
    return ParameterDumpFont;
}

void FrameTableSetParameterDumpFont(TUSIGN8 font)
{
    ParameterDumpFont = font;
}

#if defined (TYPE_4_IMPLEMENTATION) || defined (TYPE_5_IMPLEMENTATION)
void FrameTableUpdateMenuPositionDetailsForTFT(TUSIGN8 cursorPos, TUSIGN8 cursorPosLimit, TUSIGN16 firstItem)
{
    LOCAL_nValidItems = 0;
    LOCAL_selectedValidItem = 0;

    TUSIGN8 i;
    MENU_ITEM_TYPE const *pMenuItem;

    for (i = 0; i <= cursorPosLimit; i ++)
    {
        pMenuItem = FrameTableGetMenuItem((TUSIGN16)(firstItem + i));
        if (pMenuItem)
        {
            if (ValidityTestCheck((TUSIGN16)pMenuItem->validTest))
            {
                LOCAL_nValidItems ++;
            }
        }

        if (cursorPos == i)
        {
            LOCAL_selectedValidItem = LOCAL_nValidItems;
        }
    }
}

void FrameTableGetMenuPositionDetailsForTFT(TUSIGN8* p_selectedValidItem, TUSIGN8* p_nValidItems)
{
    *p_selectedValidItem = LOCAL_selectedValidItem - 1;
    *p_nValidItems = LOCAL_nValidItems - 1;
}

#endif

////////////////////////////////////////////////////////////////////////////
//
//  M   M   OOO   DDD    U   U  L      EEEEE      TTTTT  EEEEE   SSSS  TTTTT
//  MM MM  O   O  D  D   U   U  L      E            T    E      S        T
//  M M M  O   O  D   D  U   U  L      EEE          T    EEE     SSS     T
//  M   M  O   O  D  D   U   U  L      E            T    E          S    T
//  M   M   OOO   DDD     UUU   LLLLL  EEEEE        T    EEEEE  SSSS     T
//
////////////////////////////////////////////////////////////////////////////

#if defined (HMI_MODULE_TEST) && defined(HMI_MODULE_TEST_FRAMEMOVER)


// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
void FrameTableSetConfigHeaders_ModuleTest(FRAME_FORMAT_TYPE * pFirst, FRAME_FORMAT_TYPE * pLast)
{
    firstConfigHeader = pFirst;
    lastConfigHeader = pLast;
}

#endif

#if defined (HMI_MODULE_TEST) && defined(HMI_MODULE_TEST_FRAMETABLE)

TUSIGN8 FrameTableInitialise_ModuleTest(void);
TUSIGN8 GetConfigHeaderAddress_ModuleTest(void);
// FrameTableSetCurrentFrame() is extensively tested within the FrameMover Module tests
// FrameTableEnableEdit() is extensively tested within the FrameMover Module tests
// FrameTableIsEditEnabled() is extensively tested within the FrameMover Module tests
// FrameTableGetCursorPosition() is extensively tested within the FrameMover Module tests
// FrameTableGetCursorPositionLimit() is extensively tested within the FrameMover Module tests
// FrameTableSetCursorPosition() is extensively tested within the FrameMover Module tests
TUSIGN8 FrameTableGetString_ModuleTest(void);
TUSIGN8 FrameTableGetMenuItem_ModuleTest(void);
TUSIGN8 FrameTableGetCharacterSet_ModuleTest(void);
TUSIGN8 FrameTableGetConfigIconPart_ModuleTest(void);
TUSIGN8 FrameTableGetConfigIconAddress_ModuleTest(void);
TUSIGN8 FrameTableGetSignal_ModuleTest(void);

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TUSIGN8 FrameTable_ModuleTest(void)
{    TUSIGN8 rv = 0;


    rv |= FrameTableInitialise_ModuleTest();
    rv |= GetConfigHeaderAddress_ModuleTest();
    rv |= FrameTableGetString_ModuleTest();
    rv |= FrameTableGetMenuItem_ModuleTest();
    rv |= FrameTableGetCharacterSet_ModuleTest();
    rv |= FrameTableGetConfigIconPart_ModuleTest();
    rv |= FrameTableGetConfigIconAddress_ModuleTest();
    rv |= FrameTableGetSignal_ModuleTest();

    return rv;
}

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TUSIGN8 FrameTableInitialise_ModuleTest(void)
{

    FrameTableInitialise();
    if (FrameTableGetCurrentFrame() != &Frame_Operator_1)   return 1;

    return 0;
}

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TUSIGN8 GetConfigHeaderAddress_ModuleTest(void)
{
    if (FrameTableGetConfigHeaderAddress(0) != FIRSTCONFIGHEADER)   return 1;
    if (FrameTableGetConfigHeaderAddress(1) != LASTCONFIGHEADER)    return 1;
    if (FrameTableGetConfigHeaderAddress(2) != LASTCONFIGHEADER)    return 1;

    return 0;
}

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TUSIGN8 FrameTableGetString_ModuleTest(void)
{
    TEXT_IDENTIFIER_TYPE id;
    TUSIGN8 EnglishLanguage = 0;
    TUSIGN8 GermanLanguage = 1;
    TUSIGN8 InvalidLanguage = 0xFF;


    id.ssIdx = HMI_IDX;
    id.objIdx = SS_HMI_UNITS_TABLE;

    id.attribIdx = 253;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&EnglishLanguage,1);
    if (strcmp((const char*)FrameTableGetString(id), "special") != 0)      return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&GermanLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "special") != 0)      return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&InvalidLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "special") != 0)      return 1;

    id.attribIdx = 6;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&EnglishLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "psi") != 0)          return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&GermanLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "psi") != 0)          return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&InvalidLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "psi") != 0)          return 1;

    id.attribIdx = 20;  // This attribute is not supported
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&EnglishLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "Invalid") != 0)      return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&GermanLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "Invalid") != 0)      return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&InvalidLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "Invalid") != 0)      return 1;

    id.attribIdx = 35;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&EnglishLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "K") != 0)            return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&GermanLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "K") != 0)            return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&InvalidLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "K") != 0)            return 1;

    id.attribIdx = 237;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&EnglishLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "MPa") != 0)          return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&GermanLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "MPa") != 0)          return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&InvalidLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "MPa") != 0)          return 1;

    id.attribIdx = 255;  // This attribute is not supported
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&EnglishLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "Invalid") != 0)      return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&GermanLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "Invalid") != 0)      return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&InvalidLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "Invalid") != 0)      return 1;


    id.objIdx = SS_HMI_OBJ_STRINGTABLE;

    id.attribIdx = MAX_STRINGS + 1;     //Invalid string attribute
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&EnglishLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "") != 0)            return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&GermanLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "") != 0)            return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&InvalidLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "") != 0)            return 1;


    id.attribIdx = IDS_LANGUAGE;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&EnglishLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "Language") != 0)     return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&GermanLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "Sprache") != 0)      return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&InvalidLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "Language") != 0)     return 1;

    id.objIdx = 102;            // Invalid object index
    id.attribIdx = 0;           // Arbitary attribute index
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&EnglishLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "") != 0)            return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&GermanLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "") != 0)            return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&InvalidLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "") != 0)            return 1;

    id.ssIdx = HART_IDX;
    id.objIdx = 0;              // Arbitary object index
    id.attribIdx = 0;           // Arbitary attribute index

    memcpy((void *)&cuHmiNvCustomData.language,(void *)&EnglishLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "") != 0)             return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&GermanLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "") != 0)             return 1;
    memcpy((void *)&cuHmiNvCustomData.language,(void *)&InvalidLanguage,1);
    if (strcmp((const char*) FrameTableGetString(id), "") != 0)             return 1;

    return 0;
}

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TUSIGN8 FrameTableGetMenuItem_ModuleTest(void)
{
    MENU_ITEM_TYPE const *pMenuItem;

    pMenuItem = FrameTableGetMenuItem(0);
    if (pMenuItem == NULL)                                      return 1;
    if (pMenuItem->text_attribIdx != IDS_BLANK)                 return 1;

    pMenuItem = FrameTableGetMenuItem(10);
    if (pMenuItem == NULL)                                      return 1;
    if (pMenuItem->text_attribIdx != IDS_BARGRAPH)              return 1;

    pMenuItem = FrameTableGetMenuItem(20);
    if (pMenuItem == NULL)                                      return 1;
    if (pMenuItem->text_attribIdx != IDS_UPPER_RANGE_VALUE)     return 1;

    pMenuItem = FrameTableGetMenuItem(23);
    if (pMenuItem == NULL)                                      return 1;
    if (pMenuItem->text_attribIdx != IDS_OUT_SCALE_UPPER_RANGE) return 1;

    pMenuItem = FrameTableGetMenuItem(24);
    if (pMenuItem != NULL)                                      return 1;

    return 0;
}

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TUSIGN8 FrameTableGetCharacterSet_ModuleTest(void)
{
    TUSIGN8 const *pCharSet;

    pCharSet = FrameTableGetCharacterSet(0);
    if (pCharSet != &CharacterSet_default[0])   return 1;

    pCharSet = FrameTableGetCharacterSet(1);
    if (pCharSet != NULL)                       return 1;


    return 0;
}

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TUSIGN8 FrameTableGetConfigIconPart_ModuleTest(void)
{
    if (FrameTableGetConfigIconPart(IDI_ADJUST_1,0) != ICON_PART_DIAL_T1)       return 1;
    if (FrameTableGetConfigIconPart(IDI_ADJUST_1,6) != ICON_PART_BLANK)         return 1;
    if (FrameTableGetConfigIconPart(IDI_DEVICE_3,5) != ICON_PART_BELLOWS_B3)    return 1;
    if (FrameTableGetConfigIconPart(IDI_LAST_ICON+1,0) != ICON_PART_BLANK)      return 1;

    return 0;
}

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TUSIGN8 FrameTableGetConfigIconAddress_ModuleTest(void)
{
    return 0;
}

// this function not size optimized beyond low
#ifdef OPTIMIZE_V3_4
#pragma optimize=size low
#else
#pragma optimize=z 3
#endif
TUSIGN8 FrameTableGetSignal_ModuleTest(void)
{
    SIGNAL_TABLE_TYPE const *pSignal;

    pSignal = FrameTableGetSignal(0);
    if (pSignal != &signalTable[0])                                     return 1;
    if (pSignal->identifier_attribIdx != IDS_PV_IDENDIFIER)             return 1;

    pSignal = FrameTableGetSignal(1);
    if (pSignal != &signalTable[1])                                     return 1;
    if (pSignal->identifier_attribIdx != IDS_HART_OUTPUT_IDENTIFIER)    return 1;

    pSignal = FrameTableGetSignal(2);
    if (pSignal != &signalTable[2])                                     return 1;
    if (pSignal->identifier_attribIdx != IDS_OUTPUT_IDENTIFIER)         return 1;

    pSignal = FrameTableGetSignal(3);
    if (pSignal != &signalTable[3])                                     return 1;
    if (pSignal->identifier_attribIdx != IDS_OUTPUT_IDENTIFIER)         return 1;

    pSignal = FrameTableGetSignal(4);
    if (pSignal != &signalTable[4])                                     return 1;
    if (pSignal->identifier_attribIdx != IDS_TEMPERATURE_IDENTIFIER)    return 1;

    pSignal = FrameTableGetSignal(5);
    if (pSignal != &signalTable[0])                                     return 1;
    if (pSignal->identifier_attribIdx != IDS_PV_IDENDIFIER)             return 1;

    return 0;
}

#endif
